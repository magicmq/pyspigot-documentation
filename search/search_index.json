{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A Python scripting engine for your Minecraft server.</p> <p> </p>"},{"location":"#pyspigot","title":"PySpigot","text":""},{"location":"#what-is-pyspigot","title":"What is PySpigot?","text":"<p>PySpigot is a Spigot/Bukkit plugin that acts as a Python scripting engine that runs in Minecraft. Users can write Python scripts, which, for lack of a better term, act as \"mini-plugins\". Because PySpigot runs entirely in the Minecraft environment on Java, scripts have access to the full server, including the entire Bukkit API, as well as the APIs of other plugins. With PySpigot, you can write a script that does the exact same thing a plugin can but in a small fraction of the time. PySpigot is also excellent for individuals who know Python, but not Java. PySpigot is a lot like Skript, but much more powerful.</p>"},{"location":"#what-can-pyspigot-do","title":"What Can PySpigot Do?","text":"<ul> <li> <p> Write Scripts Quickly, in Python</p> <p>PySpigot scripts can do all the same things that a plugin can do. However, PySpigot scripts can be written in a fraction of the time it takes to write a full plugin.</p> <p>PySpigot is also great for people who know Python, but not Java - no Java experience is required!</p> </li> <li> <p> Write Multi-Module Projects</p> <p>PySpigot fully supports writing multi-module projects. These function similarly to multi-module Python projects and offer more ideal code organization and structuring.</p> </li> <li> <p> Easy to Use</p> <p>PySpigot's features are designed with ease of use in mind. It is easy to use for simple tasks, but you can also create really complex scripts. The possibilities are endless!</p> </li> <li> <p> Unrestricted Bukkit API Access</p> <p>Because PySpigot runs inside of the Minecraft/Java environment, PySpigot scripts have complete access to the Bukkit/Spigot API.</p> <p>Register event listeners, create commands, schedule tasks, work with config files, and more!</p> </li> <li> <p> Comprehensive Error Logging</p> <p>PySpigot includes comprehensive error logging on a per-script basis, both to console and to a script-specific log file, making debugging as easy as possible.</p> </li> <li> <p> Full Support for External Java/Python Libraries</p> <p>PySpigot includes full support for loading and working with external libraries such as the Apache Commons libraries.</p> </li> <li> <p> Highly Configurable</p> <p>PySpigot was designed to be as configurable as possible. There are several editable script-specific options, as well as a variety of plugin-wide options that can be configured.</p> </li> <li> <p> Full MySQL, MongoDB, and Redis Support</p> <p>PySpigot includes support for MySQL, MongoDB, and Redis and greatly simplifies these </p> </li> <li> <p> Full ProtocolLib Support</p> <p>PySpigot has built-in support for ProtocolLib, making it easy to work with packets. There is full support for registering packet listeners, packet modification, and sending packets.</p> </li> <li> <p> Full PlaceholderAPI Support</p> <p>PySpigot also has built-in support for PlaceholderAPI, making it easy to register placeholder expansions.</p> </li> <li> <p> Open Source, Apache 2.0 License</p> <p>PySpigot's source is fully available on GitHub, and it's licensed under the Apache 2.0 license.</p> </li> <li> <p> And More!</p> <p>I am constantly working on new features and improvements to make scripting in Minecraft the best possible experience.</p> <p>Ideas are always welcome. If you have an idea for a new feature, submit a feature request.</p> </li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>Check out any of the examples to see some examples of PySpigot scripts.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>See the Quick Start Guide for a brief tutorial. Check out the rest of the documentation for more advanced usage.</p>"},{"location":"#discord","title":"Discord","text":"<p>PySpigot has an official Discord server with help channels, bug reporting, and more. I'm usually active on Discord, so if you want to reach me, joining the Discord server is an excellent way to do so. Join the Discord server here.</p>"},{"location":"#metrics","title":"Metrics","text":"<p>PySpigot uses bStats to collect anonymous usage data for PySpigot. I use these data to inform me about PySpigot's users, including which country they are from (so that I can offer support in popular non-English languages) as well as what Minecraft and Java versions are most popular with users. bStats also collects some other useful data, including server software (Spigot, Paper, Purpur, etc.), plugin version, and number of scripts loaded. Sensitive or identifying information is not collected.</p> <p>If you would like to opt out of this feature, set <code>metrics-enabled</code> to <code>false</code> in PySpigot's config file. Alternatively, you can disable bStats server-wide by setting <code>enabled</code> to <code>false</code> in /plugins/bStats/config.yml.</p>"},{"location":"#licensing-information","title":"Licensing Information","text":"<p>PySpigot is licensed using the Apache 2.0 license. Please check out the License Info page for more information.</p>"},{"location":"managers/commands/","title":"Defining Commands","text":"<p>PySpigot allows you to define, register, and unregister commands from within scripts. These commands function in the same way as any plugin-defined command would in-game.</p> <p>For instructions on importing the command manager into your script, visit the General Information page.</p> Info <p>This is not a comprehensive guide to commands in Bukkit. For a more complete guide to commands, see Spigot's tutorial on commands here.</p>"},{"location":"managers/commands/#command-manager-usage","title":"Command Manager Usage","text":"<p>The command manager makes several functions available to you to register and unregister commands, including:</p> <ul> <li><code>registerCommand(command_function, name)</code>: The most basic way to register a command.</li> <li><code>registerCommand(command_function, tab_function, name)</code></li> <li><code>registerCommand(command_function, name, permission)</code></li> <li><code>registerCommand(command_function, tab_function, name, permission)</code></li> <li><code>registerCommand(command_function, name, aliases, permission)</code></li> <li><code>registerCommand(command_function, tab_function, name, aliases, permission)</code></li> <li><code>registerCommand(command_function, name, description, usage)</code></li> <li><code>registerCommand(command_function, tab_function, name, description, usage)</code></li> <li><code>registerCommand(command_function, name, description, usage, aliases)</code></li> <li><code>registerCommand(command_function, tab_function, name, description, usage, aliases)</code></li> <li><code>registerCommand(command_function, tab_function, name, description, usage, aliases, permission)</code>: The most comprehensive way to register a command.</li> <li><code>unregisterCommand(name)</code>: Allows you to unregister a command from your script using its name.</li> <li><code>unregisterCommand(command)</code>: Allows you to unregister a command from your script. Accepts the <code>ScriptCommand</code> object returned from any of the <code>registerCommand</code> functions.</li> </ul> <p>See the below section for a description of the arguments for the <code>registerCommand</code> functions.</p> <p>All the above <code>registerCommand</code> functions return a <code>ScriptCommand</code> object, which can be used to unregister the command later, if desired.</p> Tip <p>You do not need to unregister your commands when your script is stopped/unloaded. PySpigot will handle this for you.</p>"},{"location":"managers/commands/#function-arguments","title":"Function Arguments","text":"<p>The arguments of the above functions are described below:</p> <ul> <li><code>command_function</code>: The function that should be called when the command is run in-game or in the server console. Command functions should always return <code>True</code> or <code>False</code>. Return <code>True</code> if the command was used correctly. Return <code>False</code> if it was not. This function should also accept three arguments:<ul> <li><code>sender</code>, which represents the sender that executed the command (either a player or console),</li> <li><code>label</code>, which represents the label that was typed (either the command name or one of its aliases), and </li> <li><code>args</code>, a list of arguments passed along with the command.</li> <li>For more information, see the Spigot tutorial on commands.</li> </ul> </li> <li><code>tab_function</code>: A function that should be called to generate a list of tab-completable items when typing the command.</li> <li><code>name</code>: The name of the command being registered</li> <li><code>description</code>: A description for the command</li> <li><code>usage</code>: A message printed to the person executing the command if the usage is incorrect. This is controlled programatically by returning either <code>True</code> or <code>False</code> from the command function.</li> <li><code>aliases</code>: A list of aliases for the command.</li> <li><code>permission</code>: A permission node required to execute the command.</li> </ul>"},{"location":"managers/commands/#code-example","title":"Code Example","text":"<p>Let's look at the following code that defines and registers a command:</p> <pre><code>import pyspigot as ps # (1)!\n\ndef kick_command(sender, label, args): # (2)!\n    #Do something...\n    return True # (3)!\n\ndef tab_kick_command(sender, alias, args): # (4)!\n    #Do something...\n    return ['',] # (5)!\n\nregistered_command = ps.command.registerCommand(kick_command, tab_kick_command, 'kickplayer') # (6)!\n</code></pre> <ol> <li> <p>Here, we import PySpigot as <code>ps</code> to utilize the command manager (<code>command</code>).</p> </li> <li> <p>Here, we define a function called <code>kick_command</code> that takes three arguments, <code>sender</code>, <code>label</code>, and <code>args</code>. <code>sender</code> is who/what executed the command, <code>label</code> is exactly the command that was typed (if the command sender typed an alias, then this argument would be the alias that the command sender used). <code>args</code> is a list of <code>str</code> containing each argument that <code>sender</code> typed after the base command.</p> </li> <li> <p>Here, we return a boolean value from the function. Command functions must always return either <code>True</code> or <code>False</code>. Whether or not you should return <code>True</code> or <code>False</code> is explained above.</p> </li> <li> <p>Here, we define a function called <code>tab_kick_command</code> that takes the same parameters as <code>kick_command</code>. This function serves as the tab completer for the command. On line 9, we return a list of <code>str</code> from this function, which serves as the options that can be tab completed. Tab complete functions must return a list of <code>str</code>.</p> </li> <li> <p>Here, we return a list from the function, representing the list of tab-completable arguments for the command. Tab completion functions must always return a list of <code>str</code> if there are tab-completable items or, if there are no tab-completable items, <code>None</code> or an empty list.</p> </li> <li> <p>Here, we register the command with <code>registerCommand(command_function, tab_function, name)</code>. We also assign the returned value of <code>registerCommand</code> to <code>registered_command</code>. This is a <code>ScriptCommand</code> object, which represents the command that was registered. This can be used to unregister the command if you would like to do so later.</p> </li> </ol> <p>All commands must be registered with PySpigot's command manager to work. Commands can be registered in multiple ways. In the code above, the <code>registerCommand(function, name)</code> function is used, which takes two arguments:</p> <ul> <li>The first argument accepts the function that should be called when the command is executed.</li> <li>The second argument is the name of the command, a <code>str</code>.</li> </ul> Note <p>Command functions must return either <code>True</code> or <code>False</code>. Likewise, tab completion functions must return a list. If there are no tab complete suggestions to offer, return an empty list (<code>[]</code>).</p> <p>If a command/tab completion function does not return the correct type (or returns nothing at all), a warning message will be printed to the server console, but the command or tab completion will still complete successfully.</p>"},{"location":"managers/commands/#unregistering-a-command","title":"Unregistering a Command","text":"<p>Continuing the above code example:</p> <pre><code>ps.command.unregisterCommand(registered_command) # (1)!\n</code></pre> <ol> <li>Here, we unregister the command by passing the <code>ScriptCommand</code> object we assigned earlier when registering the command. You can also unregister a command by passing its name if you don't want to store the <code>ScriptCommand</code> object.</li> </ol> Tip <p>For more functional examples of commands, check out some of the example scripts.</p>"},{"location":"managers/commands/#summary","title":"Summary","text":"<ul> <li>Commands are defined as functions in your script. Command functions must take three parameters: a sender, label, and args (the names of these parameters can be whatever you like). The function is called when the command is executed.</li> <li>Use a tab function to return tab-completable items when typing the command.</li> <li>All commands must be registered with PySpigot's command manager using <code>command.registerCommand(function, name)</code>.</li> </ul>"},{"location":"managers/configuration/","title":"Configuration Files","text":"<p>With PySpigot, scripts can load, access, and save to configuration files. All configuration files that scripts access using the config manager are automatically stored in the <code>config</code> folder located within PySpigot's plugin folder.</p> <p>For instructions on importing the configuration manager into your script, visit the General Information page.</p> Info <p>This is not a comprehensive guide to working with config files. For more complete documentation on available methods/functions, see the JavaDocs. All methods listed here can be called from within your script.</p>"},{"location":"managers/configuration/#config-manager-usage","title":"Config Manager Usage","text":"<p>The following functions are available from the config manager:</p> <ul> <li><code>doesConfigExist(filePath)</code>: This checks if a config file exists under the given name or path. Returns <code>True</code> if the file exists, <code>False</code> if it does not.</li> <li><code>loadConfig(filePath)</code>: This loads the config, and will create a file automatically if one does not already exist. Takes the name or path of the file you wish to load and/or create. Returns a <code>ScriptConfig</code> object representing the config that was loaded/created. No default values are specified.</li> <li><code>loadConfig(filePath, defaults)</code>: This loads the config, and will create a file automatically if one does not already exist. Takes the name or path of the file you wish to load and/or create. Returns a <code>ScriptConfig</code> object representing the config that was loaded/created. Also takes a YAML-formatted string (<code>defaults</code>) that is used to specify the desired default values for the config.</li> <li><code>reloadConfig(config)</code>: This reloads a config in case there any changes to the file that need to be loaded in. Takes the config (a <code>ScriptConfig</code> object) to reload. Returns another <code>ScriptConfig</code> object representing the config that was reloaded.<ul> <li>Note: The <code>reloadConfig</code> function will be removed in a future release of PySpigot. Instead, use the <code>reload</code> function within ScriptConfig (outlined in more detail below)</li> </ul> </li> <li><code>deleteConfig(filePath)</code>: This will delete the config file with the specified name or path. Returns <code>True</code> if a file was deleted, <code>False</code> if no file existed previously under the provided name or path.</li> <li><code>getConfigFolder()</code>: This returns a Path to the folder (within the PySpigot plugin folder) where config files live.</li> </ul> Tip <p>The ConfigManager allows for usage of subfolders when working with script config files for organizational purposes. Simply pass the config file as a path to the above methods that accept a <code>filePath</code> parameter. For example, <code>ps.config_manager.loadConfig('test_script/config.yml')</code> will load the <code>config.yml</code> file in the <code>test_script</code> subfolder within the <code>configs</code> folder.</p>"},{"location":"managers/configuration/#scriptconfig-usage","title":"ScriptConfig Usage","text":"<p>Loading/reloading a config returns a <code>ScriptConfig</code> object. This object has many methods/functions that you can use:</p> <ul> <li>Multiple functions are available for getting data from your config. For a complete list of methods/functions you can use to retrieve data from your config file, see the Spigot JavaDocs</li> <li><code>set(key, value)</code>: Set a value in the config at the given key. Takes a key representing the key to write to and value which is the value to write.</li> <li><code>setIfNotExists(path, value)</code>: Set a value in the config at the given path, only if there is not already a value set at that path. Returns <code>True</code> if the path was set to the value (the path was not previously set), or <code>False</code> if the path was not set to the given value (the path was already previously set). This is useful if you would like to add new keys to your config file but you do not want to override them if they are already set. </li> <li><code>getConfigFile()</code>: Get the file that corresponds to the config.</li> <li><code>getConfigPath()</code>: Get the path for the file that corresponds to the config.</li> <li><code>load()</code>: Loads the configuration file. Under normal circumstances, this function should not be called, as it is done when <code>loadConfig</code> is called from the ScriptManager.</li> <li><code>reload()</code>: Reloads the configuration from its file. Useful if changes where made to the file since the last load/reload, as these changes will not be reflected automatically until the config is reloaded.</li> <li><code>save()</code>: This saves the config so that any values you set will be persistent. The configuration is automatically reloaded after saving.</li> </ul> Warning <p>Changes to the config are not saved to the file automatically! You must call <code>save</code> to write changes to the config file.</p>"},{"location":"managers/configuration/#config-defaults","title":"Config Defaults","text":"<p>The Bukkit configuration libraries (upon which PySpigot's configuration system is built) has a built-in system for handling default config values. Default values are values that you can specify when you load your config that the configuration system will fall back on when a value isn't defined in your config file. These default values are only used if the path/key doesn't exist in the config file. Take the following example:</p> <p>Config file: <pre><code>key-1: 'Key 1 is set'\nkey-2: 'Key 2 is set'\n</code></pre></p> <p>Script: <pre><code>import pyspigot as ps\n\nconfig_defaults = \"\"\"\nkey-1: 'Key 1'\nkey-2: 'Key 2'\nkey-3: 'Key 3'\n\"\"\" # (1)!\n\nconfig = ps.config.loadConfig('script_config.yml', config_defaults) # (2)!\n\nprint(config.getString('key-1')) # (3)!\nprint(config.getString('key-2')) # (4)!\nprint(config.getString('key-3')) # (5)!\n</code></pre></p> <ol> <li> <p>Here, a multi-line string is defined in YAML format containing all the desired default values for our config file.</p> </li> <li> <p>Here, the config file is loaded, passing the name of the config file <code>script_config.yml</code> as well as the <code>config_defaults</code> we defined earlier.</p> </li> <li> <p>Here, we print the value for <code>key-1</code> from the config file.</p> </li> <li> <p>Here, we print the value for <code>key-2</code> from the config file.</p> </li> <li> <p>Here, we print the value for <code>key-3</code> from the config file.</p> </li> </ol> <p>Console output: <pre><code>[14:17:22 INFO]: [PySpigot/test.py] [STDOUT] Key 1 is set\n[14:17:22 INFO]: [PySpigot/test.py] [STDOUT] Key 2 is set\n[14:17:22 INFO]: [PySpigot/test.py] [STDOUT] Key 3\n</code></pre></p> <p>As you can see from the console output of the above code, <code>key-1</code> and <code>key-2</code> print \"Key 1 is set\" and \"Key 2 is set\", respectively, because these are actually defined in the config file. However, since <code>key-3</code> is not defined in the config file, it defaults to the default value for <code>key-3</code>, which is \"Key 3\", specified previously in the <code>config_defaults</code> string.</p> <p>Specifying default values is particularly useful if you would like to add newer config values to an existing config file but you don't want to delete and regenerate the entire config. It's also useful if a user accidentally deletes a config value but you don't want your script to break if the config value isn't found (because it will fall back to whatever default value you specified).</p>"},{"location":"managers/configuration/#another-way-to-specify-defaults","title":"Another way to specify defaults","text":"<p>The Bukkit config system also has built-in functions that allow you to specify a default value when you get a value. For example:</p> <pre><code>import pyspigot as ps\n\nconfig = ps.config.loadConfig('script_config.yml') # (1)!\n\nprint(config.getString('key-1', 'Key 1 default')) # (2)!\nprint(config.getString('key-2', 'Key 2 default')) # (3)!\nprint(config.getString('key-3', 'Key 3 default')) # (4)!\n</code></pre> <ol> <li> <p>Here, the config file is loaded, passing the name of the config file <code>script_config.yml</code>. Note that this differs from the previous example as <code>config_defaults</code> are not specified.</p> </li> <li> <p>Here, we get the value associated with <code>key-1</code> in the config File. We also pass a default value \"Key 1 default\", which will be returned if <code>key-1</code> is not defined in the config file.</p> </li> <li> <p>Here, we get the value associated with <code>key-2</code> in the config File. We also pass a default value \"Key 2 default\", which will be returned if <code>key-2</code> is not defined in the config file.</p> </li> <li> <p>Here, we get the value associated with <code>key-3</code> in the config File. We also pass a default value \"Key 3 default\", which will be returned if <code>key-3</code> is not defined in the config file.</p> </li> </ol> <p>In the above code, default values are passed in the <code>getString</code> function, which are returned only if the value doesn't exist in the config. Similar functions exist when getting other types of values, including <code>getInt</code>, <code>getDouble</code>, <code>getLong</code>, <code>getBoolean</code>, etc.</p>"},{"location":"managers/configuration/#special-python-data-types","title":"Special Python Data Types","text":""},{"location":"managers/configuration/#lists-sets-and-tuples","title":"Lists, Sets, and Tuples","text":"<p>Lists, sets, and tuples are all saved in yaml syntax as a list, which will look like this:</p> <pre><code>list:\n  - 'item1'\n  - 'item2'\n  - 'item3'\n</code></pre>"},{"location":"managers/configuration/#dictionaries","title":"Dictionaries","text":"<p>A dictionary is represented in the <code>key: value</code> format in yaml syntax. For example, consider the following code:</p> <pre><code>thisdict = {\n  \"brand\": \"Ford\",\n  \"model\": \"Mustang\",\n  \"year\": 1964\n}\n\nscript_config.set('dict', thisdict)\n</code></pre> <p>This will output to yaml syntax in the following format:</p> <pre><code>dict:\n  year: 1964\n  model: Mustang\n  brand: Ford\n</code></pre> <p>Of course, you may also nest lists, sets, tuples, and additional dictionaries within dictionaries and they will be saved accordingly. Dictionaries are particularly useful for setting multiple config values at the same time, without having to set each value individually.</p>"},{"location":"managers/configuration/#code-example","title":"Code Example","text":"<p>Let's take a look at the following code that loads a config, reads a number and string from it, writes to it, then saves it.</p> <pre><code>import pyspigot as ps # (1)!\n\nscript_config = ps.config.loadConfig('test.yml') # (2)!\n\na_number = script_config.getInt('test-number') # (3)!\na_string = script_config.getString('test-string') # (4)!\n\nscript_config.set('test-set', 1337) # (5)!\nscript_config.save() # (6)!\n</code></pre> <ol> <li> <p>Here, we import PySpigot as <code>ps</code> to utilize the config manager (<code>config</code>).</p> </li> <li> <p>Here, we load the config using the config manager. Fortunately, the config manager is easily accessible from the <code>pyspigot</code> helper module under the variable name <code>config</code>, for easy access. The <code>loadConfig</code> function takes a string representing the name of the config file to load. If the file does not exist, it will create it automatically.</p> </li> <li> <p>Here, we read a number (<code>int</code>) from the config under the key <code>test-number</code>, and assign the value to <code>a_number</code>.</p> </li> <li> <p>Here, we read a string (<code>str</code>) from the config under the key <code>test-string</code>, and assign the value to <code>a_string</code>.</p> </li> <li> <p>Here, we set the value 1337 to the config key <code>test-set</code>.</p> </li> <li> <p>Finally, we save the config using the <code>save()</code> function. This ensures any changes made to the config (via the <code>set</code>) method are saved to the config file.</p> </li> </ol> Note <p>Configuration files are not unique to each script! Any script can access any config file. Use names that are unique.</p>"},{"location":"managers/configuration/#summary","title":"Summary","text":"<ul> <li>Scripts can load and save to config files that are automatically stored in PySpigot's plugin folder in the <code>configs</code> folder.</li> <li>To load a config, use <code>config.load(filePath)</code>. The <code>filePath</code> parameter is the name or path of the config file you wish to load (including the <code>.yml</code> extension). If the config file does not exist, it will be created for you automatically. This returns a <code>ScriptConfig</code> object that is used to access the contents of the config and write to the config.</li> <li>For all available functions/methods to get values from a loaded config, see the Javadocs.</li> <li>To set a value in a config, use <code>script_config.set(key, value)</code>, where <code>key</code> is the key you wish to write to and <code>value</code> is the value to write.</li> <li>You can set config defaults by passing a YAML-formatted string containing the default config values to the <code>loadConfig</code> function.</li> <li>Finally, to save a config, use <code>script_config.save()</code>.</li> </ul>"},{"location":"managers/databases/","title":"Database Manager","text":"<p>PySpigot includes a database manager that allows you to connect to and interact with SQL database types (including MySQL, MariaDB, PostgreSQL, and more) as well as MongoDB. Under the hood, PySpigot utilizes HikariCP for interfacing with SQL-type database servers, and the MongoDB Java Driver for interfacing with MongoDB database servers.</p> <p>For instructions on importing the database manager into your script, visit the General Information page.</p> Info <p>This is not a comprehensive guide to working with SQL or MongoDB. Please seek out the appropriate tutorials/information if you're unsure how to use SQL or MongoDB.</p>"},{"location":"managers/databases/#sql","title":"SQL","text":"<p>The database manager allows you to connect to and interact with SQL-type databases. </p>"},{"location":"managers/databases/#database-manager-usage-for-sql-databases","title":"Database Manager Usage for SQL Databases","text":"<p>There are several functions available for you to use in the database manager for interacting with SQL databases. They are:</p> <ul> <li><code>newHikariConfig()</code>: Returns a new HikariConfig object for convenience.</li> <li><code>connectSql(host, port, database, username, password)</code>: Connects to a remote SQL database with the given host, port, database name, username, and password.</li> <li><code>connectSql(host, port, database, username, password, hikariConfig)</code>: Connects to a remote SQL database with the given host, port, database name, username, password, using the provided HikariConfig.</li> <li><code>connectSql(uri)</code>: Connects to a remote SQL database with the given connection string (see below for details on connection strings).</li> <li><code>connectSql(uri, hikariConfig)</code>: Connects to a remote SQL database with the given connection string (see below for details on connection strings), using the provided HikariConfig.</li> <li><code>connectSql(hikariConfig)</code>: Connects to a remote SQL database with the given HikariConfig.</li> <li><code>disconnect(database)</code>: Disconnect and close an open connection to a database. Accepts the SqlDatabase object returned by <code>connectSql</code>.</li> </ul> <p>All of the <code>connectSql</code> functions above accomplish the same task: they will initialize a new connection to a remote database and return an <code>SQLDatabase</code> object, which can then be used to select and update tables within the database. Which <code>connectSql</code> function you use will depend on your specific use case. Of all of the above, <code>connectSql(host, port, database, username, password)</code> is the most basic, and if you're just getting started, you should probably use this one.</p> <p>The database manager also allows you to specify a connection string/URI/URL, if you want finer control over the connection parameters and settings. You may also specify options in the connection string. The <code>connectSql</code> functions that accept <code>uri</code> are functions that accept a connection string.</p> Tip <p>If you're finished using a database connection, it is good practice to close it. If you have any open database connections when your script is stopped or terminated, then these open connections will be closed automatically. If a database is closed either during or pending execution of a statement, there is no guarantee that execution of the statement will occur.</p>"},{"location":"managers/databases/#the-hikariconfig","title":"The HikariConfig","text":"<p>The HikariConfig is a configuration object that allows greater control over the SQL connection. For example, it allows you to set a minimum idle time, pool size, idle timeout time, and more. For detailed information on the HikariConfig, see the HikariCP JavaDocs.</p> <p>You may also use a HikariConfig object alone to establish a connection (via the <code>connectSql(hikariConfig)</code> function). The HikariConfig object allows you to directly specify a host, port, database, username, and password within the object. This is probably the simplest way to establish a new connection with a remote database.</p> <p>A <code>newHikariConfig()</code> function is provided in the database manager for convenience. It returns a new HikariConfig with default options that you may modify. Once you modify the options to your liking, you may then pass your HikariConfig to one of the <code>connectSql</code> functions.</p>"},{"location":"managers/databases/#the-sqldatabase-object","title":"The SqlDatabase Object","text":"<p>Once we call any of the above <code>connectSql</code> functions, a connection is established. If the connection is established successfully, then an <code>SqlDatabase</code> object is returned. The SqlDatabase object contains the functions used to interact directly with the database:</p> <ul> <li><code>getHikariDataSource()</code>: Returns the underlying HikariDataSource connection object.</li> <li><code>select(sql)</code>: Executes a select statement on the database with the provided <code>sql</code>. Returns a Map (essentially the same as a python dict), with keys that represent column names and values that represent column data (a list of objects).</li> <li><code>select(sql, values)</code>: Executes a select statement on the database with the provided <code>sql</code>, with <code>values</code> (a list of objects) that will be replaced in the <code>sql</code> statement. Returns a Map (essentially the same as a python dict), with keys that represent column names and values that represent column data (a list of objects).</li> <li><code>update(sql)</code>: Executes an update statement on the database with the provided <code>sql</code>. Returns an int that signals the number of rows affected by the update.</li> <li><code>update(sql, values)</code>: Executes an update statement on the database, with <code>values</code> (a list of objects) that will be replaced in the <code>sql</code> statement. Returns an int that signals the number of rows affected by the update.</li> </ul> <p><code>sql</code> in the above functions is simply an SQL statement. For example: <pre><code>SELECT * FROM test_table;\n</code></pre></p> <p>We can also define values that will be automatically inserted into the SQL statement. For example, we can define an SQL statement like the following: <pre><code>SELECT * FROM test_table WHERE id = ?;\n</code></pre> This statement is called a parameterized query, because it contains question marks (<code>?</code>). Question marks in the SQL statement act as placeholders, or, values that will be inserted later. This is where the <code>values</code> parameter comes into play: question marks are replaced with the values that are passed in <code>values</code>. For example, if we call <pre><code>sql.select('SELECT * FROM test_table WHERE id = ?;', [10])\n</code></pre> then the actual SQL statement sent to the server will be <pre><code>SELECT * FROM test_table WHERE id = 10;\n</code></pre> because the question mark was replaced with the value <code>10</code> we passed in <code>values</code>. This also works if we want to pass multiple values in <code>values</code>: <pre><code>sql.update('INSERT INTO test_table (id, val) VALUES (?, ?);', [11, 1])\n</code></pre> The above statement effectively becomes <code>INSERT INTO test_table (id, val) VALUES (11, 1);</code>. Note that the ordering of objects in <code>values</code> is important as it determines the order in which the placeholders are replaced in the SQL statement. The first question mark is replaced with the object at position zero, the second question mark is replaced with the object at position one, and so on.</p>"},{"location":"managers/databases/#code-example-for-sql-databases","title":"Code Example for SQL Databases","text":"<p>The following code connects to and performs some simple operations on a remote SQL database. The table being interacted with is named <code>test_table</code> and has columns <code>id</code> (auto-increment, not null, unique) and <code>value</code> (not null):</p> <pre><code>import pyspigot as ps # (1)!\n\ndb_manager = ps.database_manager() # (2)!\n\nsql = db_manager.connectSql('localhost', '3306', 'test', 'root', '') # (3)!\n\ndata = sql.select('SELECT * FROM test_table ORDER BY val DESC;') # (4)!\n\nfor column, col_data in data.items(): # (5)!\n    print(column)\n    print(col_data)\n\nrows_affected = sql.update('INSERT INTO test_table (id, val) VALUES (?, ?)', [11, 1]) # (6)!\nprint(f'Rows affected: {rows_affected}') # (7)!\n\ndb_manager.disconnect(sql) # (8)!\n</code></pre> <ol> <li> <p>Here, we import PySpigot as <code>ps</code> to utilize the database manager.</p> </li> <li> <p>Here, we get the database manager from <code>ps</code> and set it to <code>db_manager</code>.</p> </li> <li> <p>Here, we establish a new connection with <code>connectSql</code> and assign the returned object to <code>sql</code>. This variable is what we will subsequently use to interact with the database.</p> </li> <li> <p>Here, we select all data from <code>test_table</code> and order it by the column <code>val</code>, descending, and assign the selected data to the <code>data</code> variable.</p> </li> <li> <p>Here, we loop through all of the data and print the column name along with the data corresponding to that column.</p> </li> <li> <p>Here, we execute an update on <code>test_table</code> by inserting a new row with values 11 for <code>id</code> and 1 for <code>val</code>, and assign the result (number of rows affected) to the variable <code>rows_affected</code>.</p> </li> <li> <p>Here, we print the number of rows affected.</p> </li> <li> <p>Here, we close the database connection by calling the <code>disconnect</code> function from the database manager and passing our database object we got earlier when we connected with <code>connectSql</code>.</p> </li> </ol> Warning <p>It's important to keep in mind that interacting with any remote database is an I/O operation. If we run this code on the main server thread (I.E., not in an asynchronous task), then the server will hang and be unresponsive until the interaction with the remove server completes. For laggy and/or high-latency connections, this can cause significant amounts of server lag. To avoid lag, it is best practice to wrap all I/O operations in an asynchronous task. See the section below for an example.</p>"},{"location":"managers/databases/#code-example-for-sql-databases-asynchronous","title":"Code Example for SQL Databases, Asynchronous","text":"<p>The following code takes the above code example but wraps the interaction with the database in an asynchronous task. Of note, the connection to the database (<code>connectSql</code> function on line 6) is still synchronous, but we want this to remain synchronous because a failed connection affects the rest of the script's execution, and the script should terminate if the connection failes (I.E. an error is thrown).</p> <p>The code below makes use of the task manager's callback task, which runs a task asychronously, then calls back to the main server thread when the asychronous task finishes via another user-defined function.</p> <pre><code>import pyspigot as ps\n\ntask_manager = ps.task_manager()\ndb_manager = ps.database_manager()\n\nsql = db_manager.connectSql('localhost', '3306', 'test', 'root', '')\n\ndef select_data():\n    data = sql.select('SELECT * FROM test_table ORDER BY val DESC;')\n    return data\n\ndef sync_callback(data):\n    for column, col_data in data.items():\n        print(column)\n        print(col_data)\n\ntask_manager.runSyncCallbackTask(select_data, sync_callback)\n\ndef update():\n    rows_affected = sql.update('INSERT INTO test_table (id, val) VALUES (?, ?)', [11, 1])\n    print('Rows affected: ' + str(rows_affected))\n\ntask_manager.runTaskAsync(update)\n</code></pre>"},{"location":"managers/databases/#mongodb","title":"MongoDB","text":"<p>The database manager allows you to connect to and interact with Mongo databases (MongoDB).</p>"},{"location":"managers/databases/#database-manager-usage-for-mongodb","title":"Database Manager Usage for MongoDB","text":"<p>There are several functions available for you to use in the database manager for interacting with MongoDB. They are:</p> <ul> <li><code>newMongoClientSettings()</code>: Returns a new MongoClientSettings builder for convenience.</li> <li><code>connectMongo(host, port, username, password)</code>: Connects to a remote MongoDB server with the given host, port, username, and password.</li> <li><code>connectMongo(host, port, username, password, clientSettings)</code>: Connects to a remote MongoDB server with the given host, port, username, and password, using the given MongoClientSettings.</li> <li><code>connectMongo(uri)</code>: Connects to a remote MongoDB server with the given connection string.</li> <li><code>connectMongo(uri, clientSettings)</code>: Connects to a remote MongoDB server with the given connection string, using the given MongoClientSettings.</li> <li><code>connectMongo(clientSettings)</code>: Connects to a remote MongoDB server with the given MongoClientSettings.</li> <li><code>disconnect(database)</code>: Disconnect and close an open connection to a database. Accepts the MongoDatabase object returned by <code>connectMongo</code>.</li> </ul> <p>The database manager allows you to specify a connection string/URI/URL, if you want finer control over the connection parameters and settings. You may also specify options in the connection string. The <code>connectMongo</code> functions that accept <code>uri</code> are functions that accept a connection string.</p> <p>These function very similar to the functions for initializing a connection to an SQL database. The only real difference is that instead of a HikariConfig, we can use a MongoCLientSettings to specify connection settings.</p> Tip <p>If you're finished using a database connection, it is good practice to close it. If you have any open database connections when your script is stopped or terminated, then these open connections will be closed automatically. If a database is closed either during or pending execution of an operation, there is no guarantee that execution of the opteration will occur.</p>"},{"location":"managers/databases/#the-mongoclientsettings","title":"The MongoClientSettings","text":"<p>The MongoClientSettings is a configuration object that allows greater control over the MongoDB connection. For example, it allows you to set connection pool settings, connection string, encryption settings, read preference, write preference, etc. For detailed information on the MongoClientSettings, see the MongoDB documentation.</p> <p>You may also use a MongoClientSettings object alone to establish a connection (via the <code>connectMongo(clientSettings)</code> function). The MongoClientSettings builder object allows you to directly specify a connection string or host, port, database, username, and password within the object. This is probably the simplest way to establish a new connection with a remote database.</p> <p>A <code>newMongoClientSettings()</code> function is provided in the database manager for convenience. It returns a new MongoClientSettings builder with default options that you may modify. Once you modify the options to your liking, you may then call <code>build()</code> on the object and pass the result to one of the <code>connectMongo</code> functions.</p> Warning <p>Once you finish setting the options you'd like to set for the MongoClientSettings, you must call <code>build()</code> to build the settings into a readable object prior to passing it to one of the <code>connectMongo</code> functions.</p>"},{"location":"managers/databases/#the-mongodatabase-object","title":"The MongoDatabase Object","text":"<p>Once we call any of the above <code>connectMongo</code> functions, a connection is established. If the connection is established successfully, then a <code>MongoDatabase</code> object is returned. The MongoDatabase object contains the functions used to interact directly with the database.</p> <p>There are too many functions in the MongoDatabase object to list them all here. For a complete list, see the PySpigot JavaDocs.</p> <p>Additionally, the MongoDB documentation contains detailed documentation and example code. I highly recommend you check it out for information on how to work with the MongoDatabase object, since many of the functions I have defined in MongoDatabase are simply passthroughs to the underlying MongoDB library.</p> Tip <p>If you're finished using a database connection, it is good practice to close it. If you have any open database connections when your script is stopped or terminated, then these open connections will be closed automatically. If a database is closed either during or pending execution of an operation, there is no guarantee that execution of the operation will occur.</p>"},{"location":"managers/databases/#code-example-for-mongodb","title":"Code Example for MongoDB","text":"<p>The following code established a connection to a remote MongoDB server, creates a collection, inserts a document, and then retrieves the document that was created.</p> <pre><code>import pyspigot as ps\n\ndb_manager = ps.database_manager()\n\nmongo = db_manager.connectMongo('localhost', '27017', None, None)\n\nif (not mongo.doesCollectionExist('test', 'test_collection')):\n    mongo.createCollection('test', 'test_collection')\n\nmongo.insertDocument('test', 'test_collection', mongo.createDocument('test_key', 'test_value'))\n\ndocuments = mongo.getDocuments('test', 'test_collection')\n\nfor document in documents:\n    print(document)\n</code></pre> Warning <p>The above code is run sycnchronously. As outlined above, it is best to interact with an external database server in an asychronous context to avoid server lag.</p>"},{"location":"managers/databases/#summary","title":"Summary","text":"<ul> <li>The DatabaseManager allows you to connect to and interact with SQL-type and Mongo databases.</li> <li>Use the <code>connectSql</code> functions (along with the provided arguments, based on your specific situation) to connect to an SQL database.</li> <li>Use the <code>connectMongo</code> functions (along with the provided arguments, based on your specific situation) to connect to a Mongo database.</li> <li>When connecting to a database, a database object (either <code>SqlDatabase</code> or <code>MongoDatabase</code>) is returned by the connect function, which is then used to interact with the database.</li> <li>Interacting with a database is an I/O operation, and these interactions should be done in an asynchronous context, such as within a scheduled asynchronous task or within a callback task.</li> <li>Database connections are closed automatically when a script is stopped. At any other time, if you are finished using a database, it should be closed by calling the database manager <code>disconnect</code> function. The <code>disconnect</code> function takes the database object that was procured when connecting to the database.</li> </ul>"},{"location":"managers/eventlisteners/","title":"Event Listeners","text":"<p>With PySpigot's ListenerManager, scripts can register event listeners. Like Bukkit's listener system, when an event fires, its respective function in the script will be called, and the event can be utilized within the script.</p> <p>For instructions on importing the listener manager into your script, visit the General Information page.</p> Info <p>This is not a comprehensive guide to events in Bukkit. For a more complete guide on events, see Spigot's tutorial on using the event API.</p>"},{"location":"managers/eventlisteners/#listener-manager-usage","title":"Listener Manager Usage","text":"<p>There are five functions available to use from the listener manager:</p> <ul> <li><code>registerListener(function, event)</code>: Registers an event listener. Takes the function to call when the event fires (<code>function</code>) as well as the event to listen to (<code>event</code>). Returns a <code>ScriptEventListener</code>, which can be used to unregister the event later.</li> <li><code>registerListener(function, event, priority)</code>: Same as above, except also takes a <code>priority</code> (how early/late the event listener should fire relative to other listeners for the same event). The priority is a string, and represents an <code>EventPriority</code>. Returns a <code>ScriptEventListener</code>, which can be used to unregister the event later.<ul> <li>Event priorities are the same as the priorities found in Bukkit's EventPriority class.</li> </ul> </li> <li><code>registerListener(function, event, ignoreCancelled)</code>: Facilitates \"ignoring\" the event if it has been cancelled at an earlier point in time by another event listener. The listener in the script will not be called if it is cancelled elsewhere beforehand. Returns a <code>ScriptEventListener</code>, which can be used to unregister the event later.<ul> <li>This will only work with events that are cancellable. Not all events are cancellable.</li> </ul> </li> <li><code>registerListener(function, event, priority, ignoreCancelled)</code>: Registers an event listener that is ignored if cancelled and that has a priority (a combination of the previous two functions). Returns a <code>ScriptEventListener</code>, which can be used to unregister the event later.</li> <li><code>unregisterListener(event_listener)</code>: Unregisters an event listener. Takes the <code>ScriptEventListener</code> that was returned when the listener was registered.</li> </ul> Tip <p>You do not need to unregister your event listeners when your script is stopped/unloaded. PySpigot will handle this for you.</p>"},{"location":"managers/eventlisteners/#code-example","title":"Code Example","text":"<p>Let's look at the following code that defines and registers an event listener:</p> <pre><code>import pyspigot as ps # (1)!\nfrom org.bukkit.event.player import AsyncPlayerChatEvent # (2)!\n\ndef player_chat(event): # (3)!\n    print('Player sent a chat! Their message was: ' + event.getMessage())\n\nlistener = ps.listener.registerListener(player_chat, AsyncPlayerChatEvent) # (4)!\n</code></pre> <ol> <li> <p>Here, we import PySpigot as <code>ps</code> to utilize the listener manager (<code>listener</code>).</p> </li> <li> <p>Here, we import Bukkit's <code>AsyncPlayerChatEvent</code>, which is the event that we will be listening for. All events that you wish to listen to must be imported!</p> </li> <li> <p>Here, we define a function called <code>player_chat</code> that takes an event as a parameter (an AsyncPlayerChatEvent in this case). This is the function that will be called when an AsyncPlayerChatEvent occurs. Within this function, we print a message to the console that contains the message that was sent in chat (the event that fired).</p> </li> <li> <p>Here, we use the <code>registerEvent(function, event)</code> function to register our event listener, passing the function defined earlier, as well as the event we are listening for (<code>AsyncPlayerChatEvent</code>). We also assign the returned value of <code>registerEvent</code> to <code>listener</code>. This is a <code>ScriptEventListener</code> object, which represents the listener that was registered. This can be used to unregister the listener if you would like to do so later.</p> </li> </ol> <p>All event listeners must be registered with PySpigot's listener manager. In this case, we use the <code>registerEvent(function, event)</code> function. It takes two arguments:</p> <ul> <li>The first argument accepts the function that should be called when the event fires.</li> <li>The second argument accepts the event that should be listened for.</li> </ul>"},{"location":"managers/eventlisteners/#unregistering-a-listener","title":"Unregistering a Listener","text":"<p>Continuing the above code example:</p> <pre><code>ps.listener.unregisterListener(listener) # (1)!\n</code></pre> <ol> <li>Here, we unregister the listener by passing the <code>ScriptEventListener</code> object we assigned earlier when registering the listener.</li> </ol> <p>For complete documentation on available listeners and functions/methods available to use from each, see the Spigot JavaDocs.</p>"},{"location":"managers/eventlisteners/#summary","title":"Summary","text":"<ul> <li>All events that you wish to use should be imported using Python's import syntax.</li> <li>All event listeners should be defined as functions in your script that accept a single parameter, the event (the parameter name can be whatever you like).</li> <li>All event listeners must be registered with PySpigot's listener manager using <code>listener.registerEvent(function, event)</code>.</li> <li>When registering an event listener, the <code>registerEvent</code> functions all return a <code>ScriptEventListener</code>, which can be used to unregister the listener.</li> </ul>"},{"location":"managers/messaging/","title":"Plugin Messaging","text":"Note <p>This manager is available on the Bukkit/Paper version of PySpigot only.</p> <p>Plugin messaging is a powerful way for plugins to communicate with clients. Additionally, when the Minecraft server is running behind a proxy such as BungeeCord or Velocity, plugin messaging can also be used to communicate directly with the proxy server.</p> <p>PySpigot includes a plugin messaging manager that makes it easier for scripts and projects to send plugin messages and register plugin message listeners.</p> <p>For instructions on importing the messaging manager into your script, visit the General Information page.</p>"},{"location":"managers/messaging/#general-description","title":"General Description","text":"<p>Originally, plugin messaging was implemented so that server-sided plugins could send any kind of data to client-sided mods. Before, such messages would have needed to implement custom packets, but the problem with this is that the Minecraft client would get disconnected from servers using those custom packets with an incomprehensible error message, because the client would be unable to read that packet. To fix this issue, Mojang introduced the \"Custom Plugin Message Packets\".</p> <p>The anatomy of a Plugin Message Packet is as such:</p> <ol> <li>The name of the \"channel\" (also named \"tag\" in BungeeCord) the plugin message transits through</li> <li>The size of the plugin message</li> <li>The actual data/payload of the message</li> </ol> <p>Note that the messaging manager handles all of this under the hood, and all that is needed from the user end to send a mesasge is the player to send the plugin message to, the channel, and the message payload.</p>"},{"location":"managers/messaging/#the-bungeecord-channel","title":"The BungeeCord Channel","text":"<p>BungeeCord exposes a special plugin channel to the backend/Bukkit servers called \"BungeeCord\". Within the BungeeCord channel, there are several message types that can be leveraged to perform actions or fetch data about a particular server, or even send custom data. For a complete list of message types and what they do, see this table.</p> <p>The messaging manager includes a special function called <code>sendBungeeMessage</code> for sending messages on the BungeeCord channel. See the section below on sending plugin messages.</p>"},{"location":"managers/messaging/#messaging-manager-usage","title":"Messaging Manager Usage","text":"<p>The messaging manager can be used to both send and listen to (receive) plugin messages:</p>"},{"location":"managers/messaging/#sending-plugin-messages","title":"Sending Plugin Messages","text":"<p>The messaging manager provides three functions that can be used to send plugin messages:</p> <ul> <li><code>sendBungeeMessage(player, message_type, *payload)</code>: Used to send traditional messages on the \"BungeeCord\" channel, such as a message to send a player to another server, or a message to retrieve the player count of another server.<ul> <li><code>player</code>: The player to use when sending the message. Note that at least one player must be online in order to send a plugin message.</li> <li><code>message_type</code>: The type of message to send. For a complete list, see this table.</li> <li><code>*payload</code>: Any number of arguments which are send as the message payload. Typically, this is a server name or player name (or both) and depends on the message type.</li> </ul> </li> <li><code>sendMessage(player, channel, *payload)</code>: Used to send a plugin message to any channel.<ul> <li><code>player</code>: The player to use when sending the message.</li> <li><code>channel</code>: The channel to send the message on.</li> <li><code>*payload</code>: Any number of arguments which are send as the message payload. Allowed payload types include the Java types <code>String</code>, <code>Integer</code>, <code>Short</code>, <code>Byte</code>, <code>Boolean</code>, and <code>byte[]</code> (a byte array).</li> </ul> </li> <li><code>sendRawMessage(player, channel, payload)</code>: This is equivalent to <code>sendMessage</code>, except that the payload should be passed as a raw array of bytes.<ul> <li><code>player</code>: The player to use when sending the message.</li> <li><code>channel</code>: The channel to send the message on.</li> <li><code>payload</code>: The payload, formatted as a raw byte array.</li> </ul> </li> </ul>"},{"location":"managers/messaging/#sending-a-player-to-another-server-on-the-proxy","title":"Sending a player to another server on the proxy","text":"<p>The following example demonstrates how to use the message manager to send a player to another server on the proxy, using the \"BungeeCord\" channel:</p> <pre><code>import pyspigot as ps # (1)!\n\nfrom org.bukkit import Bukkit\n\nmessaging = ps.message_manager()\n\nplayer = Bukkit.getPlayer('Player') # (2)!\n\nmessaging.sendBungeeMessage(player, 'Connect', 'lobby') # (3)!\n</code></pre> <ol> <li> <p>Here, we import PySpigot as <code>ps</code> to access the messaging manager (<code>message_manager()</code>).</p> </li> <li> <p>Here, we arbitrarily get a player by the name \"Player\". Note that this is purely arbitrary, you could get a player via any means (such as if a player triggers an event).</p> </li> <li> <p>Here, we send a plugin message using the player. We specify a message type of \"Connect\" (the message type which connects the player to another server) and then specify the server name as the payload (\"lobby\" in this case).</p> </li> </ol>"},{"location":"managers/messaging/#the-forward-message-type","title":"The Forward Message Type","text":"<p>The \"BungeeCord\" channel includes a special message type called \"Forward\" that allows you to send a custom message to other servers on the proxy. The \"Forward\" message type is thus very useful when something happens on one server and the information should be shared with all other servers. For example, if a player is banned on one server, you may want to transmit this information to all servers on the proxy so that the player can be banned on those servers as well.</p> Warning <p>All message types, including the \"Forward\" message type, require a player to be online on both the sending and receiving servers. Consider using alternative messaging systems (such as redis) if dispatch and receipt of the information is critical.</p> <p>The following example demonstrates how to use the \"Forward\" message type to communicate to another server that a player was banned:</p> <pre><code>import pyspigot as ps # (1)!\n\nfrom org.bukkit import Bukkit\n\nmessaging = ps.message_manager()\n\nplayer = Bukkit.getPlayer('Player') # (2)!\nbanned_player = ... # (3)!\n\nmessaging.sendBungeeMessage(player, 'Forward', 'ALL', 'InternalChannel', banned_player.getUniqueId().toString()) # (4)!\n</code></pre> <ol> <li> <p>Here, we import PySpigot as <code>ps</code> to access the messaging manager (<code>message_manager()</code>).</p> </li> <li> <p>Here, we arbitrarily get a player by the name \"Player\". Note that in this example, it need not be the same player that was banned. This player is simply being used to send the plugin message. It could be any online player.</p> </li> <li> <p>Here, we fetch the player that was banned. </p> </li> <li> <p>There's a lot happening on this line: First, we use <code>player</code> to send the plugin message. Next, we specify \"Forward\" as the message type. Next, this message type requires we specify the server to send the message to, as well as an \"internal channel\". <code>ALL</code> denotes that we want the message to be sent to ALL servers (but you could also specify a specific server name here). We use <code>InternalChannel</code> for the channel name, but any name would do. Finally, we send the actual payload, which is the banned player's UUID, converted to a String with <code>toString()</code>.</p> </li> </ol> Note <p>The \"Forward\" message type allows for sending any type and amount of payload to the internal channel. For example, any of the following would work:</p> <pre><code>messaging.sendBungeeMessage(player, 'Forward', 'ALL', 'InternalChannel', 'Message 1', 'Message 2') # Payload is \"Message 1\" and \"Message 2\"\nmessaging.sendBungeeMessage(player, 'Forward', 'ALL', 'InternalChannel', 'PySpigot is an awesome plugin', 42) # Payload is \"PySpigot is an awesome plugin\" and \"42\"\nmessaging.sendBungeeMessage(player, 'Forward', 'ALL', 'InternalChannel', 2, 4, 8, 16, 32) # Payload is \"2\", \"4\", \"8\", \"16\", and \"32\"\n</code></pre>"},{"location":"managers/messaging/#sending-a-message-to-a-custom-channel","title":"Sending a message to a custom channel","text":"<p>The following example demonstrates how to send a message to a custom channel:</p> <pre><code>import pyspigot as ps # (1)!\n\nfrom org.bukkit import Bukkit\n\nmessaging = ps.message_manager()\n\nplayer = Bukkit.getPlayer('Player') # (2)!\n\nmessaging.sendMessage(player, 'custom_channel', 'Payload') # (3)!\n</code></pre> <ol> <li> <p>Here, we import PySpigot as <code>ps</code> to access the messaging manager (<code>message_manager()</code>).</p> </li> <li> <p>Here, we fetch an online player to send the message. Again, this is entirely arbitrary, any online player could be used.</p> </li> <li> <p>Finally, we send the message containing the payload \"Payload\" to the channel with the name \"custom_channel\".</p> </li> </ol>"},{"location":"managers/messaging/#receiving-messages","title":"Receiving Messages","text":"<p>When sending messages that respond with something meaningful, we also need a plugin message listener to listen for incoming plugin messages. The messaging manager provides several functions for registering and unregistering plugin message listeners:</p> <ul> <li><code>registerListener(function, channel)</code>: Registers a plugin message listener to listen on the given channel. When a message is received, the function is called.<ul> <li><code>function</code>: The function that should be called when a message is received on the channel. This function should accept three arguments: <code>channel</code>, the channel the message was received on, <code>player</code>, the source of the message, and <code>message</code>: the message payload itself.</li> <li><code>channel</code>: The channel to listen on</li> <li>Returns a <code>ScriptPluginMessageListener</code> object, which represents a registered plugin message listener. Can be used later to unregister the listener if desired.</li> </ul> </li> <li><code>unregisterListener(listener)</code>: Unregisters a previously registered plugin message listener.<ul> <li><code>listener</code>: The listener to unregister</li> </ul> </li> <li><code>unregisterListeners(script)</code>: Unregister all plugin message listeners belonging to a script.<ul> <li><code>script</code>: The script whose plugin message listeners should be unregistered</li> </ul> </li> </ul> Note <p>When a script/project is stopped, all its plugin message listeners are automatically unregistered. You do not need to unregister them yourself.</p>"},{"location":"managers/messaging/#receiving-a-player-count-message","title":"Receiving a player count message","text":"<p>Suppose a plugin message was sent with the type \"PlayerCount\", a message type which can be used to fetch the player count of another server on the proxy: <code>sendBungeeMessage(player 'PlayerCount', 'server1')</code>. We expect to receive a reply stating the number of players on the server \"server1\".</p> <p>The following example demonstrates how to handle and parse the response:</p> <pre><code>import pyspigot as ps # (1)!\nfrom com.google.common.io import ByteStreams # (2)!\nfrom org.bukkit import Bukkit\n\nmessaging = ps.message_manager()\n\ndef message_received(channel, player, message): # (3)!\n    input = ByteStreams.newDataInput(message) # (4)!\n\n    subchannel = input.readUTF() # (5)!\n    if subchannel == 'PlayerCount': # (6)!\n        server = in.readUTF() # (7)!\n        player_count = in.readInt() # (8)!\n        print('The player count of server ' + server + ' is ' + str(player_count))\n\nlistener = messaging.registerListener(message_received, 'BungeeCord') # (9)!\n\nplayer = Bukkit.getPlayer('Player') # (10)!\nmessaging.sendBungeeMessage(player, 'PlayerCount', 'lobby') # (11)!\n</code></pre> <ol> <li> <p>Here, we import PySpigot as <code>ps</code> to access the messaging manager (<code>message_manager()</code>).</p> </li> <li> <p>Here, we import the Java class <code>ByteStreams</code>, for use when reading the received message.</p> </li> <li> <p>Here we declare a new function that accepts a channel, player, and message. This function serves as the listener function and is called when a message is received. <code>channel</code> represents the channel the message was received on. <code>player</code> is the player the message was sent through. <code>message</code> is a byte array representing the actual payload of the message.</p> </li> <li> <p>Since the message payload is a raw byte array, we need to use the <code>ByteStreams</code> class to decode it. Here, we create a new data input to read the message.</p> </li> <li> <p>Here, we read the first part of the message, which is the subchannel of the message, the same thing as the message type.</p> </li> <li> <p>We are interested in receiving a message regarding the player count, so we check if the subchannel is \"PlayerCount\".</p> </li> <li> <p>Next, we read the server whose player count we are fetching. This is a string, so we call <code>in.readUTF()</code>.</p> </li> <li> <p>Finally, we read the actual player count of the server. This is an int, so we call <code>in.readInt()</code>.</p> </li> <li> <p>Here, we register a new plugin message listener, passing the listener function we defined earlier, as well as the channel we want to listen on, \"BungeeCord\" in this case.</p> </li> <li> <p>Here, we fetch an online player to send the message. Again, this is entirely arbitrary, any online player could be used.</p> </li> <li> <p>Here, we send a plugin message using the player. We specify a message type of \"PlayerCount\" (the message type which fetches the player count of a particular server) and then specify the server name as the payload (\"lobby\" in this case).</p> </li> </ol>"},{"location":"managers/messaging/#receiving-a-forward-message","title":"Receiving a \"Forward\" message","text":"<p>Suppose we sent a plugin message of the \"Forward\" type, and we want to receive this message on another server. We sent the message with the following: <code>sendBungeeMessage(player, 'Forward', 'ALL', 'InternalChannel', banned_player.getUniqueId().toString())</code>.</p> <p>The following example demonstrates how to handle and parse the response:</p> <pre><code>import pyspigot as ps # (1)!\nfrom com.google.common.io import ByteStreams # (2)!\nfrom java.io import DataInputStream # (3)!\nfrom java.io import ByteArrayInputStream # (4)!\nfrom org.bukkit import Bukkit\n\nmessaging = ps.message_manager()\n\ndef message_received(channel, player, message): # (5)!\n    input = ByteStreams.newDataInput(message) # (6)!\n\n    subchannel = input.readUTF() # (7)!\n    if subchannel == 'InternalChannel': # (8)!\n        length = in.readShort() # (9)!\n        msg_bytes = bytearray(length) # (10)!\n        in.readFully(msg_bytes) # (11)!\n\n        msg_in = DataInputStream(ByteArrayInputStream(msg_bytes)) # (12)!\n        message = msg_in.readUTF()  # (13)!\n        print('Message received: ' + message)\n</code></pre> <ol> <li> <p>Here, we import PySpigot as <code>ps</code> to access the messaging manager (<code>message_manager()</code>).</p> </li> <li> <p>Here, we import the Java class <code>ByteStreams</code>, for use when reading the received message.</p> </li> <li> <p>Here, we import the Java class <code>DataInputStream</code>, for use when reading the received message.</p> </li> <li> <p>Here, we import the Java class <code>ByteArrayInputStream</code>, for use when reading the received message.</p> </li> <li> <p>Here we declare a new function that accepts a channel, player, and message. This function serves as the listener function and is called when a message is received. <code>channel</code> represents the channel the message was received on. <code>player</code> is the player the message was sent through. <code>message</code> is a byte array representing the actual payload of the message.</p> </li> <li> <p>Since the message payload is a raw byte array, we need to use the <code>ByteStreams</code> class to decode it. Here, we create a new data input to read the message.</p> </li> <li> <p>Here, we read the first part of the message, which is the subchannel of the message, which is the internal channel specified when sending the message.</p> </li> <li> <p>We are interested in receiving the message on our specific internal channel only, so we check if the subchannel is \"InternalChannel\".</p> </li> <li> <p>Next, we read the length of the inner message payload.</p> </li> <li> <p>Next, we create a new empty byte array, with a length corresponding to the length of the inner message payload we fetched on the previous line.</p> </li> <li> <p>Here, we read the actual content of the inner payload into the empty byte array we created earlier.</p> </li> <li> <p>Next, we initialize a new input stream to translate the inner message payload from a raw byte array to human-readable text.</p> </li> <li> <p>Finally, we read the string value of the inner message payload, which should be the UUID of the player, as specified earlier.</p> </li> </ol>"},{"location":"managers/messaging/#summary","title":"Summary","text":"<ul> <li>The plugin message manager can be used to send and receive plugin messages.</li> <li>To send standard BungeeCord plugin messages, use the <code>sendBungeeMessage(player, message_type, *payload)</code> function.</li> <li>For a complete list of BungeeCord plugin messages that can be sent/received, see this page.</li> <li>To send messages on a custom channel, use the <code>sendMessage(player, channel, *payload)</code> function.</li> <li>To receive messages, create a listener function and register the listener with the <code>unregisterListener(listener)</code> function.</li> <li>Plugin message listeners are automatically unregistered when a script is stopped.</li> </ul>"},{"location":"managers/placeholders/","title":"Registering PlaceholderAPI Placeholders","text":"Warning <p>The Placeholder manager is an optional manager. This manager should only be accessed if the PlaceholderAPI plugin is present on the server when the PySpigot plugin is enabled.</p> <p>PySpigot includes a manager that interfaces with PlaceholderAPI if you would like to register placeholder expansions in your script.</p> <p>For instructions on importing the placeholder manager into your script, visit the General Information page.</p>"},{"location":"managers/placeholders/#placeholder-manager-usage","title":"Placeholder Manager Usage","text":"<p>All placeholders created by scripts will follow this general format: <code>%script:&lt;scriptname&gt;_&lt;placeholder&gt;%</code>, where <code>&lt;scriptname&gt;</code> is the name of your script (without .py), and <code>&lt;placeholder&gt;</code> is the specific placeholder, which you will handle yourself in a placeholder \"replacer\" function. See the code example below for details.</p> <p>Relational placeholders can also be registered with the placeholder manager, and they follow the general format <code>%rel_script:&lt;scriptname&gt;_&lt;placeholder&gt;%</code>, where <code>&lt;scriptname&gt;</code> is the name of your script (without .py), and <code>&lt;placeholder&gt;</code> is the specific placeholder, which you will handle yourself in the relational placeholder \"replacer\" function. See the code example below for details.</p> <p>There are several functions available from the placeholder manager for registering/unregistering placeholders:</p> <ul> <li><code>registerPlaceholder(placeholder_function)</code>: Registers a new placeholder expansion with default author (\"Script Author\") and version (\"1.0.0\").<ul> <li>When the placeholder is used, <code>placeholder_function</code> is called. Should return the text that should replace the placeholder.</li> <li>Returns a <code>ScriptPlaceholder</code>, which represents the placeholder that was registered.</li> </ul> </li> <li><code>registerPlaceholder(placeholder_function, relational_placeholder_function)</code>: Registers a new placeholder expansion with default author (\"Script Author\") and version (\"1.0.0\").<ul> <li>When the placeholder is used, <code>placeholder_function</code> is called. Should return the text that should replace the placeholder. This argument can be <code>None</code>.</li> <li>When a relational placeholder is used, <code>relational_placeholder_function</code> is used. Should return the text that should replace the placeholder. This argument can be <code>None</code>.</li> <li>Returns a <code>ScriptPlaceholder</code>, which represents the placeholder that was registered.</li> </ul> </li> <li><code>registerPlaceholder(placeholder_function, author, version)</code>: Registers a new placeholder expansion with a custom author and version.<ul> <li>When the placeholder is used, <code>placeholder_function</code> is called. Should return the text that should replace the placeholder.</li> <li>Returns a <code>ScriptPlaceholder</code>, which represents the placeholder that was registered.</li> </ul> </li> <li><code>registerPlaceholder(placeholder_function, relational_placeholder_function, author, version)</code>: Registers a new placeholder expansion with a custom author and version.<ul> <li>When the placeholder is used, <code>placeholder_function</code> is called. Should return the text that should replace the placeholder.</li> <li>When a relational placeholder is used, <code>relational_placeholder_function</code> is used. Should return the text that should replace the placeholder. This argument can be <code>None</code>.</li> <li>Returns a <code>ScriptPlaceholder</code>, which represents the placeholder that was registered.</li> </ul> </li> <li><code>unregisterPlaceholder(placeholder)</code>: Unregisters a previously registered placeholder. Takes a ScriptPlaceholder that was previously returned by the <code>registerPlaceholder</code> function.</li> </ul> Tip <p>You do not need to unregister your placeholders when your script is stopped/unloaded. PySpigot will handle this for you.</p> Note <p>Scripts can only have one placeholder expansion registered at a time. To see how to define multiple placeholders for a script, see the code example below.</p>"},{"location":"managers/placeholders/#code-examples","title":"Code Examples","text":""},{"location":"managers/placeholders/#regular-placeholder","title":"Regular Placeholder","text":"<p>Let's look at the following code that defines and registers a placeholder expansion and replaces two placeholders:</p> <pre><code>import pyspigot as ps # (1)!\n\ndef replace(offline_player, placeholder): # (2)!\n    if placeholder == 'placeholder1': # (3)!\n        return 'Replace placeholder 1!'\n    elif placeholder == 'placeholder2': # (4)!\n        return 'Replace placeholder 2!'\n\nplaceholder = ps.placeholder.registerPlaceholder(replace, None) # (5)!\n</code></pre> <ol> <li> <p>Here, we import PySpigot as <code>ps</code> to utilize the placeholder manager (<code>placeholder</code>).</p> </li> <li> <p>Here, we define <code>replace</code>, a function that will be called when the placeholder is used. This function takes two parameters. <code>offline_player</code> is a Bukkit API OfflinePlayer that represents the player associated with the placeholder. <code>placeholder</code> is the text of the specific placeholder.</p> </li> <li> <p>Here, we check if <code>placeholder</code> is equal to the specific placeholder <code>placeholder1</code>, a placeholder we define. If <code>placeholder</code> is equal to <code>placeholder1</code>, then we return the \"replaced\" text.</p> </li> <li> <p>Here, we use <code>elif</code> to check if <code>placeholder</code> is equal to another specific placeholder <code>placeholder2</code>, another placeholder we define. If <code>placeholder</code> is equal to <code>placeholder2</code>, then we return the \"replaced\" text.</p> </li> <li> <p>Here, we register our placeholder expansion with the <code>registerPlaceholder</code> function, passing the replacer function we defined earlier. We also assign the returned value of <code>registerPlaceholder</code> to <code>placeholder</code>. This is a <code>ScriptPlaceholder</code> object, which represents the placeholder expansion that was registered. This can be used to unregister the placeholder expansion if you would like to do so later. We also pass <code>None</code> for the second argument of this function, as the second argument accepts a function to replace relational placeholders, which we are not doing in this example.</p> </li> </ol> <p>Note that the replacer function for the placeholder expansion takes two arguments:</p> <ul> <li>The <code>offline_player</code> argument is the player associated with the placeholder. For example, if the placeholder is used in the context of a command, then <code>offline_player</code> would be the player that typed/executed the command. If no player was associated with the placeholder when it was used, then this argument will be <code>None</code>.</li> <li>The <code>placeholder</code> argument is the name of the placeholder that was used.</li> </ul> <p>All placeholder expansion functions should follow this syntax.</p> Warning <p>In the above example, and with all placeholders, <code>offline_player</code> could be <code>None</code> if there is no player associated with the placeholder.</p> <p>If the name of the script is <code>test.py</code>, the placeholders in the above example would be <code>%script:test_placeholder1%</code> and <code>%script:test_placeholder2%</code>.</p>"},{"location":"managers/placeholders/#relational-placeholder","title":"Relational Placeholder","text":"<p>Let's look at the following code that defines and registers a placeholder expansion for a relational placeholder.</p> <pre><code>import pyspigot as ps # (1)!\n\ndef replace_relational(player_one, player_two, placeholder): # (2)!\n    if placeholder == 'player_distance': # (3)!\n        return str(player_one.getLocation().distance(player_two.getLocation())) # (4)!\n\nplaceholder = ps.placeholder.registerPlaceholder(None, replace_relational) # (5)!\n</code></pre> <ol> <li> <p>Here, we import PySpigot as <code>ps</code> to utilize the placeholder manager (<code>placeholder</code>).</p> </li> <li> <p>Here, we define <code>replace_relational</code>, a function that will be called when the relational placeholder is used. This function takes three parameters. <code>player_one</code> is the first player and <code>player_two</code> is the second player associated with the relational placeholder. <code>placeholder</code> is the text of the specific relational placeholder.</p> </li> <li> <p>Here, we check if <code>placeholder</code> is equal to the specific relational placeholder, <code>player_distance</code> in this case.</p> </li> <li> <p>Here, we return the distance from player one to player two for the text to be replaced.</p> </li> <li> <p>Here, we register our placeholder expansion with the <code>registerPlaceholder</code> function, passing the replacer function we defined earlier. We also assign the returned value of <code>registerPlaceholder</code> to <code>placeholder</code>. This is a <code>ScriptPlaceholder</code> object, which represents the placeholder expansion that was registered. This can be used to unregister the placeholder expansion if you would like to do so later. We also pass <code>None</code> for the first argument of this function, as the first argument accepts a function to replace regular placeholders, which we are not doing in this example.</p> </li> </ol> <p>If the name of the script is <code>test.py</code>, the placeholder in the above example would be <code>%rel_script:test_player_distance%</code>.</p> Tip <p>Multiple relational placeholders can be registered at the same time (using the same replacer function) by following the structure of the example in the previous section.</p>"},{"location":"managers/placeholders/#unregistering-a-placeholder","title":"Unregistering a Placeholder","text":"<p>Continuing the above code example:</p> <pre><code>ps.placeholder.unregisterPlaceholder(placeholder) # (1)!\n</code></pre> <ol> <li>Here, we unregister the placeholder expansion by passing the <code>ScriptPlaceholder</code> object we assigned earlier when registering the placeholder.</li> </ol>"},{"location":"managers/placeholders/#multiple-placeholders","title":"Multiple Placeholders","text":"<p>As you can see in the above example, you need not register a new placeholder expansion for each specific placeholder you want to define. Instead, all you need to do is check if the <code>placeholder</code> parameter of your replacer function is equal to the placeholder you want to define using <code>if</code> and <code>elif</code>.</p>"},{"location":"managers/placeholders/#summary","title":"Summary","text":"<ul> <li>Placeholders defined by scripts follow the format <code>%script:&lt;scriptname&gt;_&lt;placeholder&gt;%</code>.</li> <li>Relational placeholders follow the format <code>%rel_script:&lt;scriptname&gt;_&lt;placeholder&gt;%</code>.</li> <li>Regular placeholder replacer functions should take two parameters, <code>offline_player</code> and <code>placeholder</code>. You can name them whatever you like. It will be called when the placeholder is used. <code>offline_player</code> is the player associated with the placeholder, if there is one. <code>placeholder</code> is the specific placeholder that was used.</li> <li>Relational placeholder replacer functions should take three parameters, <code>player_one</code>, <code>player_two</code>, and <code>placeholder</code>. You can name them whatever you like. It will be called when the placeholder is used. <code>player_one</code> and <code>player_two</code> are the two players associated with the relational placeholder. <code>placeholder</code> is the specific placeholder that was used.</li> <li>Register your placeholder with PySpigot's placeholder manager using <code>registerPlaceholder(placeholder_function, relational_placeholder_function)</code> or <code>registerPlaceholder(placeholder_function, relational_placeholder_function, author, version)</code>.</li> <li>Each script can only have one placeholder expansion registered at a time. Check the <code>placeholder</code> parameter of your replacer function (using <code>if</code> and <code>elif</code>) to handle multiple placeholders.</li> <li>When registering a placeholder expansion, the register functions all return a <code>ScriptPlaceholder</code>, which can be used to unregister the placeholder expansion at a later time.</li> </ul>"},{"location":"managers/protocollib/","title":"Working with ProtocolLib","text":"Warning <p>The Protocol manager is an optional manager. This manager should only be accessed if the ProtocolLib plugin is present on the server when the PySpigot plugin is enabled.</p> <p>PySpigot includes a manager that interfaces with ProtocolLib if you would like to work with packets in your script.</p> <p>For instructions on importing the placeholder manager into your script, visit the General Information page.</p>"},{"location":"managers/protocollib/#protocol-manager-usage","title":"Protocol Manager Usage","text":"<p>There are several functions available from the protocol manager for registering and unregistering packet listeners:</p> <ul> <li><code>registerPacketListener(function, packet_type)</code></li> <li><code>registerPacketListener(function, packet_type, listener_priority)</code>: <code>listener_priority</code> is a the priority of the listener. This is analogous to EventPriority for Bukkit events.<ul> <li>For information on listener priority, see ProtocolLib's ListenerPriority class.</li> </ul> </li> <li><code>unregisterPacketListener(packet_listener)</code>: Takes a packet listener returned by one of the register functions.</li> <li><code>createPacket(packet_type)</code>: Creates and returns a packet with the given type.<ul> <li>See the PacketType class for a complete list of packet types.</li> </ul> </li> <li><code>sendServerPacket(player, packet)</code>: Sends a packet to the provided player.</li> <li><code>broadcastServerPacket(packet)</code>: Broadcasts a packet to all players on the server.</li> <li><code>broadcastServerPacket(packet, entity)</code>: Broadcasts a packet to all players who are monitoring the given entity at the time of the packet being sent.</li> <li><code>broadcastServerPacket(packet, entity, include_tracker)</code>: Broadcasts a packet to all players who are monitoring the given entity. <code>includeTracker</code> is used to specify if the packet should also be broadcasted to the entity (in addition to the players tracking the entity), e.g. <code>true</code> or <code>false</code>.</li> <li><code>broadcastServerPacket(packet, origin, max_observer_distance)</code>: Broadcasts a packet to all players within a given max observer distance from an origin location (center point).</li> <li><code>broadcastServerPacket(packet, target_players)</code>: Broadcasts a packet to a list of target players.</li> </ul> Tip <p>You do not need to unregister your packet listeners when your script is stopped/unloaded. PySpigot will handle this for you.</p>"},{"location":"managers/protocollib/#asynchronous-listeners","title":"Asynchronous Listeners","text":"<p>The protocol manager also supports registering asynchronous listeners. Asynchronous listeners allow you to delay packet transmission, among other things. You may also register timeout listeners that can handle packets that time out on sending.</p> <p>To get the asynchronous protocol manager, call <code>async()</code>. For example,</p> <pre><code>import pyspigot as ps\n\nasync_manager = ps.protocol.async()\n</code></pre> <p>The following functions are avialable for use from the asynchronous protocol manager:</p> <ul> <li><code>registerAsyncPacketListener(function, packet_type)</code></li> <li><code>registerAsyncPacketListener(function, packet_type, listener_priority)</code></li> <li><code>registerTimeoutPacketListener(function, packet_type)</code></li> <li><code>registerTimeoutPacketListener(function, packet_type, listener_priority)</code></li> <li><code>unregisterAsyncPacketListener(packet_listener)</code>: Takes a packet listener returned by one of the register functions.</li> </ul> Note <p>See ProtocolLib's documentation for more detailed infromation regarding asynchronous and timeout listeners.</p>"},{"location":"managers/protocollib/#code-example","title":"Code Example","text":"<p>Let's look at the following code that defines and registers a chat packet listener:</p> <pre><code>import pyspigot as ps # (1)!\nfrom com.comphenix.protocol import PacketType # (2)!\n\ndef chat_packet_event(event): # (3)!\n    packet = event.getPacket() # (4)!\n    message = packet.getStrings().read(0) # (5)!\n    print(f'Player sent a chat! Their message was: {message}')\n\npacket_listener = ps.protocol.registerPacketListener(chat_packet_event, PacketType.Play.Client.CHAT) # (6)!\n</code></pre> <ol> <li> <p>Here, we import PySpigot as <code>ps</code> to utilize the protocol manager (<code>protocol</code>).</p> </li> <li> <p>Here, we import <code>PacketType</code> from ProtocolLib. This will be used to define which packet we want to listen to.</p> </li> <li> <p>Here, we define the function <code>chat_packet_event</code>, a function that will be called when the packet we are listening to is intercepted. This function has one parameter, <code>event</code>, which represents the event that occurred (the chat packet that was received).</p> </li> <li> <p>Here, we get the packet that was intercepted and assign it to <code>packet</code>.</p> </li> <li> <p>Here, we read the data (the chat message) from the packet, and subsequently print the message that was intercepted on the next line.</p> </li> <li> <p>Here, we call the protocol manager to register the packet listener, passing the function we defined on line 5, <code>chat_packet_event</code>, and the packet we want to listen for, <code>PacketType.Play.Client.CHAT</code>, and assign the returned value to <code>packet_listener</code>.</p> </li> </ol> <p>All packet listeners must be registered with PySpigot's protocol manager. Registering a packet listener is very similar to registering an event listener with PySpigot's listener manager, except that a packet type is passed to the register function insead of an event.</p> <ul> <li>The first argument accepts the function that should be called when the packet is intercepted.</li> <li>The second argument accepts the packet type to listen to.</li> </ul> <p>The <code>registerPacketListener</code> function returns a <code>ScriptPacketListener</code>, which represents the packet listener that was registered. This can be used to unregister the packet listener at a later time.</p> <p>For a complete list of available packet types, see the PacketType class. Packet types are broken up into several types: <code>Configuration</code>, <code>Handshake</code>, <code>Login</code>, <code>Play</code>, and <code>Status</code>, based on what stage of gameplay they are sent/received. Each of these categories is further subdivided into <code>Client</code> and <code>Server</code> based on whether the packet originated from the client or the server.</p>"},{"location":"managers/protocollib/#unregistering-a-packet-listener","title":"Unregistering a Packet Listener","text":"<p>Continuing the above code example:</p> <pre><code>ps.protocol.unregisterPacketListener(listener) # (1)!\n</code></pre> <ol> <li>Here, we unregister the packet listener by passing the <code>ScriptPacketListener</code> object we assigned earlier when registering the packet listener.</li> </ol>"},{"location":"managers/protocollib/#summary","title":"Summary","text":"<ul> <li>To define the packet type for your listener, you must import <code>PacketType</code> from ProtocolLib.</li> <li>All packet listeners should be defined as functions in your script that accept a single parameter, the packet event (the parameter name can be whatever you like).</li> <li>All packet listeners must be registered with PySpigot's packet manager. This can be done in a variety of ways, but the most basic way is by using <code>registerPacketListener(function, packet_type)</code>.</li> <li>Packet listeners are called asynchronously. Any code that interfaces with Bukkit or PySpigot should be run synchronously. You can do this by using the task manager (<code>runTask(function)</code>)</li> <li>When registering a packet listener, the register functions all return a <code>ScriptPacketListener</code>, which can be used to unregister the listener.</li> </ul>"},{"location":"managers/redis/","title":"Redis Manager","text":"<p>PySpigot includes a Redis manager to allow you to connect to and interact with redis servers. Under the hood, PySpigot utilizes lettuce for interfacing with remote Redis server instances. There are two ways the RedisManager allows you to interact with redis servers: by issuing commands (I.E. interacting with the redis database) and by publishing and subscribing to redis' pub/sub messaging system. These are implemented in PySpigot via the RedisCommandClient and RedisPubSubClient, respectively. PySpigot also includes a generic ScriptRedisClient that you may create if you would like to work with other aspects of Redis such as Redis Sentinel or Redis Cluster.</p> <p>For instructions on importing the redis manager into your script, visit the General Information page.</p> Note <p>This is not a comprehensive guide to working with redis. Please seek out the appropriate tutorials/information if you're unsure.</p>"},{"location":"managers/redis/#redis-client-type","title":"Redis Client Type","text":"<p>For organizational purposes, there are three different types of redis clients available to use based on your specific use case. These are specified using the <code>ClientType</code> parameter when initializing/opening a redis client through the Redis Manager. The client types available are:</p> <ul> <li><code>ClientType.BASIC</code>: This is a generic redis client with no built-in functionality. You can use it if you have a specific use case that the other two redis client types aren't well-suited for.</li> <li><code>ClientType.COMMAND</code>: This client type allows for submitting and executing commands on a redis server.</li> <li><code>ClientType.PUB_SUB</code>: This client allows for connection to and publishing/subscription to redis pub/sub messaging channels.</li> </ul> <p>Which client you use will depend on your specific use case. For example, if you wish to suscribe to and publish to a redis pub/sub channel, you should use the <code>PUB_SUB</code> client type. If you want to do more than one thing at a time, you should open a new connection for each type of activity you wish to do. For example, if you wish to utilize pub/sub messaging and commands, you should open two connections, one with the <code>COMMAND</code> client type, and another for the <code>PUB_SUB</code> client type.</p> Note <p>The lettuce library includes functionality for both synchronous and asynchronous operations, and this is also reflected in PySpigot. For example, the pub/sub client has ability to publish messages synchronously and asynchronously. In most cases, you should be performing operations asynchronously.</p>"},{"location":"managers/redis/#generic-basic-redis-client","title":"Generic (Basic) Redis Client","text":"<p>The basic redis client provides access to the underlying RedisClient for you to access whatever you wish. No other functionality is implemented. The object that corresponds to this client type is <code>ScriptRedisClient</code>.</p> <p>Available functions:</p> <ul> <li><code>getRedisURI()</code>: Get the RedisURI associated with the client.</li> <li><code>getClientOptions()</code>: Get the ClientOptions associated with the client.</li> <li><code>getRedisClient()</code>: Get the underlying redis client associated with the <code>ScriptRedisClient</code>.</li> </ul> <p>For more information, see the Basic Usage section of the lettuce documentation. See the Code Examples section below for example usage.</p>"},{"location":"managers/redis/#command-client","title":"Command Client","text":"<p>The command client allows for submitting and executing commands on the redis server. Lettuce supports 400+ commands; these can all be viewed in the link to the lettuce documentation at the end of this section. The object that corresponds to this client type is <code>RedisCommandClient</code>.</p> <p>Available functions:</p> <ul> <li>All functions in the generic <code>ScriptRedisClient</code> as outlined above, plus:</li> <li><code>getConnection()</code>: Returns the stateful redis connection of the client.</li> <li><code>getCommands()</code>: Returns a <code>RedisCommands</code> object representing the RedisCommands API for the client connection.</li> <li><code>getAsyncCommands()</code>: Returns a <code>RedisAsyncCommands</code> object representing the RedisAsyncCommands API for the client connection.</li> </ul> <p>For more information, see the Command Interfaces section of the lettuce documentation. See the Code Examples section below for example usage.</p>"},{"location":"managers/redis/#pubsub-client","title":"Pub/Sub Client","text":"<p>The pub/sub client allows for subscribing and publishing to messaging channels on a redis server. The object that corresponds to this client type is <code>RedisPubSubClient</code>.</p> <p>Available functions:</p> <ul> <li>All functions in the generic <code>ScriptRedisClient</code> as outlined above, plus:</li> <li><code>registerListener(function, channel)</code>: Registers a new synchronous listener. Takes a function, which will be called when a message is received, and <code>channel</code>, the name of the channel to listen to. Returns a <code>ScriptPubSubListener</code> object, which represents the listener that was registered.</li> <li><code>registerSyncListener(function, channel)</code>: Registers a new synchronous listener. Takes a function, which will be called when a message is received, and <code>channel</code>, the name of the channel to listen to. Returns a <code>ScriptPubSubListener</code> object, which represents the listener that was registered.</li> <li><code>registerAsyncListener(function, channel)</code>: Registers a new asynchronous listener. Takes a function, which will be called when a message is received, and <code>channel</code>, the name of the channel to listen to. Returns a <code>ScriptPubSubListener</code> object, which represents the listener that was registered.</li> <li><code>unregisterListener(listener)</code>: Unregisters a listener. Takes a <code>ScriptPubSubListener</code> to unregister.</li> <li><code>unregisterListeners(channel)</code>: Unregisters all listeners listening on the provided channel.</li> <li><code>publish(channel, message)</code>: Publishes a message to the given channel synchronously. Takes the channel to publish to, and the message to publish. Returns a number representing the number of clients that received the message.</li> <li><code>publishSync(channel, message)</code>: Publishes a message to the given channel synchronously. Takes the channel to publish to, and the message to publish. Returns a number representing the number of clients that received the message.</li> <li><code>publishAsync(channel, message)</code>: Publishes a message to the given channel asynchronously. Takes the channel to publish to, and the message to publish. Returns a future that will return a number representing the number of clients that received the message when the operation completes.</li> </ul> <p>For more information, see the Publish/Subscribe section of the lettuce documentation. See the Code Examples section below for example usage.</p>"},{"location":"managers/redis/#using-the-redis-manager","title":"Using the Redis Manager","text":"<p>There are several functions available for you to use in the redis manager to facilitate interaction with a redis server. They are:</p> <ul> <li><code>newRedisURI()</code>: Returns a new, empty RedisURI builder for convenience.</li> <li><code>newClientOptions()</code>: Returns a new ClientOptions builder for convenience.</li> <li><code>openRedisClient(clientType, ip, port, password)</code>: Opens a connection with the remote redis server with the specified IP, port, and password, using the specified client type. Uses the default client options.</li> <li><code>openRedisClient(clientType, ip, port, password, clientOptions)</code>: Opens a connection with the remote redis server with the specified IP, port, and password, using the specified client type. Uses the provided client options.</li> <li><code>openRedisClient(clientType, redisURI)</code>: Opens a connection with the remote redis server with the given RedisURI connection string, using the specified client type. Uses the default client options.</li> <li><code>openRedisClient(clientType, redisURI, clientOptions)</code>: Opens a connection with the remote redis server with the given RedisURI connection string, using the specified client type. Uses the provided client options.</li> <li><code>closeRedisClient(client)</code>: Closes the provided redis client.</li> <li><code>closeRedisClientAsync(client)</code>: Closes the provided redis client asynchronously.</li> </ul> Tip <p>If you're finished using a redis client, it is good practice to close it. If you have any open redis clients when your script is stopped or terminated, then these open clients will be closed automatically. If a redis client is closed either during or pending execution of a transaction, the client will attempt to wait for completion of the pending transactions prior to closing, but there is no guarantee that the transactions will complete successfully.</p>"},{"location":"managers/redis/#the-redisuri","title":"The RedisURI","text":"<p>The RedisURI builder is a convenience object that allows you to easily build a URI connection string for connecting to a remote redis server. Using a URI is probably the most convenient way to establish a connection with a remote redis server, because you can also specify connection settings within the URI, in addition to IP, port, password, etc. For more information on usage, see the lettuce documentation.</p> <p>A <code>newRedisURI()</code> function is provided in the redis manager for convenience in obtaining a new RedisURI builder object.</p>"},{"location":"managers/redis/#the-redis-clientoptions","title":"The redis ClientOptions","text":"<p>The ClientOptions builder object is a convenience object provided by lettuce that allows you to have greater control over the settings that correspond to the connection. For example, it allows you to set auto reconnect, buffer usage ratio, and request queue size. For more information on ClientOptions, see the lettuce documentation.</p> <p>A <code>newClientOptions()</code> function is provided in the redis manager for convenience in obtaining a new ClientOptions builder object.</p>"},{"location":"managers/redis/#code-examples","title":"Code Examples","text":""},{"location":"managers/redis/#general-client-example","title":"General Client Example","text":"<p>The following example utilizes the basic client to connect to a remote redis server.</p> <pre><code>import pyspigot as ps # (1)!\nfrom dev.magicmq.pyspigot.manager.redis import ClientType # (2)!\n\nredis = ps.redis_manager() # (3)!\n\nbasic_client = redis.openRedisClient(ClientType.BASIC, 'localhost', '6379', None) # (4)!\n\nclient = redis_client.getRedisClient() # (5)!\n\n# Do something with the redis client...\n</code></pre> <ol> <li> <p>Here, we import PySpigot as <code>ps</code> to utilize the redis manager.</p> </li> <li> <p>Here, we import <code>ClientType</code> so it can be used later.</p> </li> <li> <p>Here, we get the database manager from <code>ps</code> and set it to <code>redis</code>.</p> </li> <li> <p>Here, we open a new redis client with the <code>BASIC</code> client type, using the provided IP/address, port, and no password. We assign the connected client to <code>basic_client</code>.</p> </li> <li> <p>Here, we fetch the underlying redis client from the PySpigot basic client, and assign it to <code>client</code>. At this point, you are able to work with the underlying redis client however you wish.</p> </li> </ol>"},{"location":"managers/redis/#command-client-example","title":"Command Client Example","text":"<p>The following example utilizes the command client to connect to and submit a command to a remote redis server.</p> <pre><code>import pyspigot as ps # (1)!\nfrom dev.magicmq.pyspigot.manager.redis import ClientType # (2)!\n\nredis = ps.redis_manager() # (3)!\n\ncommand_client = redis.openRedisClient(ClientType.COMMAND, 'localhost', '6379', None) # (4)!\n\ncommands = command_client.getCommands() # (5)!\n\ncommands.set('test_record', 'Helloredis!') # (6)!\n\nprint(commands.get('test_record')) # (7)!\n</code></pre> <ol> <li> <p>Here, we import PySpigot as <code>ps</code> to utilize the redis manager.</p> </li> <li> <p>Here, we import <code>ClientType</code> so it can be used later.</p> </li> <li> <p>Here, we get the database manager from <code>ps</code> and set it to <code>redis</code>.</p> </li> <li> <p>Here, we open a new redis client with the <code>COMMAND</code> client type, using the provided IP/address, port, and no password. We assign the connected client to <code>command_client</code>.</p> </li> <li> <p>Here, we fetch redis commands from the command client and assign it to the <code>commands</code> variable.</p> </li> <li> <p>Here, we submit a new command record <code>test_record</code> with the value <code>Helloredis!</code>.</p> </li> <li> <p>Here, we verify that the command was submitted by getting the command record from <code>commands</code> and printing its value.</p> </li> </ol>"},{"location":"managers/redis/#pubsub-client-example","title":"Pub/Sub Client Example","text":"<p>The following example utilizes the pub/sub client to connect to a remote redis server and subscribe to and submit messages to its pub/sub messaging system.</p> <pre><code>import pyspigot as ps # (1)!\nfrom dev.magicmq.pyspigot.manager.redis import ClientType # (2)!\n\nredis = ps.redis_manager() # (3)!\n\npub_sub_client = redis.openRedisClient(ClientType.PUB_SUB, 'localhost', '6379', None) # (4)!\n\ndef message_received(channel, message): # (5)!\n    print('Received message on channel \\'' + channel + '\\': ' + message)\n\nlistener = pub_sub_client.registerAsyncListener(message_received, 'test_channel') # (6)!\n\nnum_received = pub_sub_client.publishAsync('test_channel', 'This is a test message!') # (7)!\n\npub_sub_client.unregisterListener(listener) # (8)!\n</code></pre> <ol> <li> <p>Here, we import PySpigot as <code>ps</code> to utilize the redis manager.</p> </li> <li> <p>Here, we import <code>ClientType</code> so it can be used later.</p> </li> <li> <p>Here, we get the database manager from <code>ps</code> and set it to <code>redis</code>.</p> </li> <li> <p>Here, we open a new redis client with the <code>PUB_SUB</code> client type, using the provided IP/address, port, and no password. We assign the connected client to <code>pub_sub_client</code>.</p> </li> <li> <p>Here, we define a new function called <code>message_received</code>, that accepts two arguments: <code>channel</code> (a string), and <code>message</code> (also a string). Inside the function, we print a message that contains <code>channel</code> and <code>message</code>.</p> </li> <li> <p>Here, we register a new asynchronous listener, passing the previously defined function <code>message_received</code>, as well as the channel we want to listen to (<code>test_channel</code> in this case). We assign the registered listener to <code>listener</code> so that we can unregister it later.</p> </li> <li> <p>Here, we publish a message asynchronously to the channel <code>test_channel</code> with the content <code>This is a test message!</code>. All functions that publish a message to a channel (both sychronous and asynchronous) return a value that represents the number of clients that received the message. We assign this value to <code>num_received</code>.</p> </li> <li> <p>Here, we unregister the previously registered listener by passing <code>listener</code> to the <code>unregisterListener</code> function.</p> </li> </ol> Note <p>When a message is received on the <code>test_channel</code> channel, the <code>message_received</code> function is called automatically, and it will be passed the name of the channel (the <code>channel</code> argument), which would be <code>test_channel</code> in this case, as well as the content of the message (the <code>message</code> argument).</p> Note <p>Note that because the message is published asynchronously, <code>num_received</code> is a RedisFuture object. Additional code, not shown here, is required to fetch the value from this object. If you need help with this, ask on Discord.</p> Warning <p>As outlined previously, functions are included to execute redis operations both synchronously and asynchronously. In general, it is best to do things asynchronously, to avoid server hangs and lag (since most of these functions perform interactions with a remote redis server, these are all I/O operations and are thus relatively slow to complete).</p>"},{"location":"managers/redis/#summary","title":"Summary","text":"<ul> <li>The RedisManager allows you to connect to and interact with remote redis servers.</li> <li>There are three available client types: <code>ClientType.BASIC</code>, <code>ClientType.COMMAND</code>, and <code>ClientType.PUB_SUB</code>. Which one you should use depends on your specific use case.</li> <li>Use the <code>openRedisClient</code> functions (along with the client type and other provided options, based on your specific situation) to connect to a redis server.</li> <li>When connecting to a redis server, a redis client object (will be either a <code>ScriptRedisClient</code>, <code>RedisCommandClient</code>, or a <code>RedisPubSubClient</code>, depending on the specified client type) is returned by the <code>openRedisClient</code> functions, which is then used to interact with redis.</li> <li>Interacting with a redis is an I/O operation. Except in very limited contexts, asynchronous functions should be used over the synchronous ones. For example, if using the <code>RedisPubSubClient</code>, <code>publishAsync</code> should be used instead of <code>publish</code> or <code>publishSync</code>.</li> <li>Redis clients are closed automatically when a script is stopped. At any other time, if you are finished using a redis client, it should be closed by calling either <code>closeRedisClient</code> or <code>closeRedisClientAsync</code> from the redis manager. The <code>closeRedisClient</code>/<code>closeRedisClientAsync</code> functions take the redis client object that was returned when opening the client.</li> </ul>"},{"location":"managers/scripts/","title":"Script Manager","text":"<p>The script manager serves as the de facto core of PySpigot, handling the loading, running, and unloading of scripts. It also oversees interactions between scripts and all the other managers within PySpigot. Typically, you won't need to interact directly with the script manager, as most operations are performed by the script manager automatically. However, if needed, you can access the script manager from within your script to load, run, or unload scripts programmatically.</p> <p>For instructions on importing the script manager into your script, visit the General Information page.</p> Warning <p>Use extreme caution when loading/unloading scripts through other scripts. This is a powerful but potentially destructive feature that can lead to unexpected behavior and errors.</p>"},{"location":"managers/scripts/#script-manager-usage","title":"Script Manager Usage","text":"<p>Using the script manager to load, run and unload scripts is relatively simple. There are three functions available to perform these operations:</p> <ul> <li><code>script.loadScript(name)</code>: Loads a script with the given name. Returns a <code>RunResult</code> which represents the outcome of loading the script. See the below section for more information on <code>RunResult</code>.</li> <li><code>script.loadScript(path)</code>: Loads a script with the given file path. Returns a <code>RunResult</code> which represents the outcome of loading the script. See the below section for more information on <code>RunResult</code>.</li> <li><code>script.unloadScript(name)</code>: Unloads a script with he given name. This function will return <code>True</code> if the script unloaded successfully, or <code>False</code> if the script did not unload successfully. Unsuccessful unloads are usually accompanied by an error message printed to the console and to the script's log file (if file logging is enabled for the script).</li> </ul> <p>In addition, the script manager contains server other useful functions:</p> <ul> <li><code>script.isScriptRunning(name)</code>: Check if a script is running with the given name. Returns <code>True</code> or <code>False</code> accordingly.</li> <li><code>script.getScriptPath(name)</code>: Gets the absolute path to a script with the given name. Useful if subfolders are being utilized within the <code>scripts</code> folder.</li> <li><code>script.getScript(name)</code>: Get a running script. Returns a <code>Script</code> object if a running script was found with the given name, otherwise returns <code>None</code>. See the Script Object section below for more information on the Script object.</li> <li><code>script.getLoadedScripts()</code>: Returns a <code>Set</code> of all loaded/running scripts (as <code>Script</code> objects).</li> <li><code>script.getLoadedScriptNames()</code>: Returns a <code>Set</code> of all loaded/running script names (as <code>str</code>s).</li> <li><code>script.getAllScriptPaths()</code>: Returns a <code>Set</code>, sorted alphabetically, of all script paths (taking into account subfolders) within the <code>scripts</code> folder. </li> <li><code>script.getAllScriptNames()</code>: Returns a <code>Set</code>, sorted alphabetically, containing the names of all scripts within the <code>scripts</code> foler (taking into account subfolders).</li> </ul> Danger <p>Never unload a script from within itself! This will lead to unexpected behavior and errors.</p>"},{"location":"managers/scripts/#run-result","title":"Run Result","text":"<p>The <code>RunResult</code> is a value that represents the outcome of loading a script. Both of the <code>loadScript</code> functions return a <code>RunResult</code> representing the outcome of the load operation. There are four possible outcomes:</p> RunResult Description <code>SUCCESS</code> The script loaded and ran successfully. The script is currently running. <code>FAIL_DISABLED</code> Running the script failed because the script is disabled as per its script options (in <code>script_options.yml</code> or elsewhere) <code>FAIL_PLUGIN_DEPENDENCY</code> Running the script failed because it depends on one or more plugins that are not running on the server. <code>FAIL_ERROR</code> Running the script failed because there was an error when it ran. The error will be printed to the server console (and to the script's log file, if enabled). <code>FAIL_DUPLICATE</code> Running the script failed because there is a script already running with the same name. <code>FAIL_SCRIPT_NOT_FOUND</code> Running the script failed because a script was not found in the <code>scripts</code> folder with the given name. <p>The <code>RunResult</code> class is accessed by importing <code>dev.magicmq.pyspigot.manager.script.RunResult</code>.</p>"},{"location":"managers/scripts/#the-script-object","title":"The Script Object","text":"<p>The <code>Script</code> object is the in-memory representation of a running script. It holds several key values related to a script, including its name, log file, options, and underlying Jython interpreter object. These can be accessed with the following functions:</p> <ul> <li><code>getFile()</code>: Returns the <code>File</code> pertaining to the script.</li> <li><code>getPath()</code>: Returns the absolute path of the script.</li> <li><code>getName()</code>: Returns the name of the script.</li> <li><code>getSimpleName()</code>: Returns the name of the script, without the extension (<code>.py</code>) at the end.</li> <li><code>getOptions()</code>: Returns a <code>ScriptOptions</code> object representing the script's options. See the JavaDocs for a list of functions available in <code>ScriptOptions</code>.</li> <li><code>getInterpreter()</code>: Returns the script's underlying Jython interpreter object (<code>PythonInterpreter</code>).</li> <li><code>getLogger()</code>: Returns the script's <code>ScriptLogger</code> object.</li> <li><code>getLogFileName()</code>: Returns the script's log file name. This function always returns a file name for the script, even if file logging is disabled in its options.</li> <li><code>getUptime()</code>: Returns the script's uptime in milliseconds.</li> </ul> Warning <p>Again, exercise extreme caution when interacting with this portion of PySpigot, particularly the underlying Jython interpreter. Unexpected behavior can occur.</p>"},{"location":"managers/scripts/#code-examples","title":"Code Examples","text":"<p>Let's look at some code that loads, runs and unloads a script:</p>"},{"location":"managers/scripts/#loading-and-running-a-script","title":"Loading and Running a Script","text":"<pre><code>import pyspigot as ps # (1)!\nfrom dev.magicmq.pyspigot.manager.script import RunResult # (2)!\n\nrun_result = ps.script.loadScript('script.py') # (3)!\n\nif (run_result == RunResult.SUCCESS): # (4)!\n    print('The script is running!')\nelif (run_result == RunResult.FAIL_ERROR): # (5)!\n    print('The script did not load due to an error!')\n</code></pre> <ol> <li> <p>Here, we import PySpigot as <code>ps</code> to utilize the script manager (<code>script</code>).</p> </li> <li> <p>Here, we import <code>RunResult</code> to utilize it later to determine the outcome of loading the script.</p> </li> <li> <p>Here, we load the script with the name <code>script.py</code>, and we assign the outcome of loading the script (the <code>RunResult</code>) to <code>run_result</code>.</p> </li> <li> <p>Here, we check if the outcome of loading the script was <code>RunResult.SUCCESS</code> (which means the script loaded successfully and is currently running) and print a message to the console if this was the case.</p> </li> <li> <p>Here, we check if the outcome of loading the script was <code>RunResult.FAIL_ERROR</code> (which means the script did not load due to an error) and print a message to the console if this was the case.</p> </li> </ol>"},{"location":"managers/scripts/#unloading-a-script","title":"Unloading a Script","text":"<pre><code>import pyspigot as ps # (1)!\n\nunload_result = ps.script.unloadScript('script.py') # (2)!\n\nif (unload_result == True): # (3)!\n    print('The script unloaded successfully without errors!')\n</code></pre> <ol> <li> <p>Here, we import PySpigot as <code>ps</code> to utilize the script manager (<code>script</code>).</p> </li> <li> <p>Here, we unload the script with the name <code>script.py</code>. We assign the returned value (<code>True</code> or <code>False</code>, depending on outcome) to <code>unload_result</code>.</p> </li> <li> <p>Here, we check if the outcome of unloading the script was <code>True</code> (which means the script unloaded successfully without errors), and print a message to the console if this was the case.</p> </li> </ol>"},{"location":"managers/scripts/#summary","title":"Summary","text":"<ul> <li>Use the script manager to load/run and unload a script from within another script.</li> <li>You must use both <code>loadScript</code> and <code>runScript</code> to load and run a script, as loading and running are two separate operations.</li> <li><code>loadScript</code> returns a script object that should be passed to <code>runScript</code>. It will return <code>None</code> if the script did not load successfully.</li> <li><code>runScript</code> returns a <code>RunResult</code> which can be used to determine the outcome of running the script.</li> <li><code>unloadScript</code> returns <code>True</code> or <code>False</code>, <code>True</code> if the script unloaded successfully, or <code>False</code> if it did not.</li> <li>Never attempt to unload a script from within itself. This will lead to bugs/errors.</li> </ul>"},{"location":"managers/tasks/","title":"Defining Tasks","text":"<p>Through PySpigot, scripts can interact with Bukkit's task scheduler and schedule/run synchronous and asynchronous tasks. These allow you to run code at later times, at intervals, repeating, and on a thread other than the main server thread. The task manager also has built-in support for asynchronous tasks with synchronous callbacks.</p> <p>For instructions on importing the task manager into your script, visit the General Information page.</p> Info <p>This is not a comprehensive guide to scheduling tasks. For a more complete guide to tasks and scheduler programming, see Bukkit's tutorial on using the scheduler here. Note that much of this information pertains to writing plugins in Java, but the general ideas are nevertheless helpful to understand.</p>"},{"location":"managers/tasks/#task-manager-usage","title":"Task Manager Usage","text":"<p>There are several functions in the task manager available for you to use in your script:</p> <ul> <li><code>runTask(function, functionArgs)</code>: Run a synchronous task as soon as possible. Takes the function to call when the task runs. Also takes any number of arguments that should be passed to the function when the task runs.</li> <li><code>runTaskAsync(function, functionArgs)</code>: Run an asychronous task (a task on a thread other than the main server thread). Takes the function to call when the task runs. Also takes any number of arguments that should be passed to the function when the task runs.</li> <li><code>runTaskLater(function, delay, functionArgs)</code>: Run a synchronous task at some point in the future after the specified delay. Takes the function to call when the task runs and the delay to wait (in ticks) before running the task. Also takes any number of arguments that should be passed to the function when the task runs.</li> <li><code>runTaskLaterAsync(function, delay, functionArgs)</code>: Run an asynchronous task at some point in the future after the specified delay. Takes the function to call when the task runs and the delay to wait (in ticks) before running the task. Also takes any number of arguments that should be passed to the function when the task runs.</li> <li><code>scheduleRepeatingTask(function, delay, interval, functionArgs)</code>: Run a synchronous repeating task that repeats every specified interval. Takes the function to call each time the task runs, the delay to wait (in ticks) before running the task, and the interval (in ticks) at which the task should be run. Also takes any number of arguments that should be passed to the function when the task runs.</li> <li><code>scheduleAsyncRepeatingTask(function, delay, interval, functionArgs)</code>: Run an asynchronous repeating task that repeats every specified interval. Takes the function to call each time the task runs, the delay to wait (in ticks) before running the task, and the interval (in ticks) at which the task should be run. Also takes any number of arguments that should be passed to the function when the task runs.</li> <li><code>runSyncCallbackTask(function, callback, functionArgs)</code>: Schedules an asynchronous task with a synchronous callback. Takes the function to call for the asynchronous portion, and another function to call for the synchronous portion. Also takes any number of arguments that should be passed to the function (asynchronous portion) when the task runs.</li> <li><code>runSyncCallbackTaskLater(function, callback, delay, functionArgs)</code>: Schedules an asynchronous task with a synchronous callback to run at some point in the future after the specified delay. Takes the function to call for the asynchronous portion, another function to call for the synchronous portion, and the delay to wait (in ticks) before running the task. Also takes any number of arguments that should be passed to the function (asynchronous portion) when the task runs.</li> <li><code>stopTask(task)</code>: Stop/Cancel a task. Takes the task object of the task to stop.</li> </ul> <p>Any time a task is scheduled, a <code>Task</code> object is returned. This can be used to cancel the task later, if desired. Tasks can be stopped either via the <code>stopTask</code> function, as outlined above, or via the Task object itself, by calling <code>task.cancel()</code>.</p> <p>In the above functions, <code>functionArgs</code> is an optional argument. If the function to call does not accept any arguments, you do not need to specify any.</p> Note <p>20 ticks of in-game time is one real-world second (in a server without TPS lag). Therefore, one tick is equal to 1/20 of a second.</p>"},{"location":"managers/tasks/#basic-code-example","title":"Basic Code Example","text":"<p>Let's take a look at the following code that defines and starts a synchronous repeating task:</p> <pre><code>import pyspigot as ps # (1)!\n\na_string = 'Test'\n\ndef run_task(arg): # (2)!\n    #Do something...\n\ntask = ps.scheduler.scheduleRepeatingTask(run_task, 0, 100, a_string) # (3)!\n</code></pre> <ol> <li> <p>Here, we import PySpigot as <code>ps</code> to utilize the task manager (<code>scheduler</code>).</p> </li> <li> <p>Here, we define a function called <code>run_task</code> that takes one argument.</p> </li> <li> <p>Here, we register our task as a synchronous repeating task with the task manager, passing the <code>run_task</code> function, our desired delay (0 ticks), our desired interval (100 ticks), and the variable we want to pass to the task function each time the task is ran (the <code>a_string</code> variable we defined earlier on line 3). We then assign the returned value, a <code>Task</code> object, to the <code>task</code> variable. We can use this to cancel the task later.</p> </li> </ol> <p>Like listeners, all tasks must be registered and run with PySpigot's task manager. There are many different ways to start tasks depending on if we want the task to be synchronous, ascynchronous, and/or repeating, but here we want our task to be synchronous and repeating, so we use <code>scheduleRepeatingTask(function, delay, interval, functionArgs)</code>, which in this case takes four arguments:</p> <ul> <li>The first argument accepts the function that should be called when the task runs (either once or repeatedly at a fixed interval).</li> <li>The second argument is the delay (in ticks) that the scheduler should wait before starting the task when it is registered.</li> <li>The third argument is the interval (in ticks) that the task should be run.</li> <li>The final arguments (fourth only in this case) are used to specify the arguments that should be passed to the function.</li> </ul>"},{"location":"managers/tasks/#passing-multiple-arguments-to-a-tasks-function","title":"Passing Multiple Arguments to a Task's Function","text":"<p>If we wanted <code>run_task</code> in the above example to take two arguments instead of one, we would modify the code like so:</p> <pre><code>import pyspigot as ps\n\na_string = 'Test'\nanother_string = 'Test 2'\n\ndef run_task(arg, arg2):\n    #Do something...\n\ntask = ps.scheduler.scheduleRepeatingTask(run_task, 0, 100, a_string, another_string)\n</code></pre> <p>This example is very similar to the first, except that we define another string (<code>another_string</code>) and pass it (along with <code>a_string</code>) to the task manager when we register the task on line 8. These two strings are then passed, in order, to <code>run_task</code> when it is called by the task.</p> <p>As you can see, all arguments to be passed are added at the end of the function that registers the task, in the appropriate order that they should be passed.</p>"},{"location":"managers/tasks/#callback-tasks","title":"Callback Tasks","text":"<p>The task manager also includes a callback task, which is a special task that runs asynchronously, then runs another synchronous task upon completion of the asynchronous task. This task type is quite useful in situations where you want to do work asynchronously, and then process the result of that work in a sychronous context. For example, consider a situation where a server has an SQL database that stores player data. When a player joins, the data should be fetched from the database asynchronously to avoid server lag, but it can't be applied to the player asynchronously, since all interaction with Bukkit and the server should be done synchronously. Therefore, a synchronous callback is useful in this situation to bring the data that was obtained from the database back to the main server thread for further processing and to apply it to the player.</p>"},{"location":"managers/tasks/#callback-task-example","title":"Callback Task Example","text":"<p>The following is a simple example of how to use a callback task:</p> <pre><code>import pyspigot as ps\n\ndef async_task():\n    print('Asynchronous!')\n    data = 'some data'\n    return data\n\ndef sync_task(data):\n    print('Synchronous!')\n    print(data)\n\ntask = ps.scheduler.runSyncCallbackTask(async_task, sync_task)\n</code></pre> <p>The following conosle output is observed:</p> <pre><code>[STDOUT] Asynchronous!\n[STDOUT] Synchronous!\n[STDOUT] some data\n</code></pre> <p>There are a few things to note regarding this example:</p> <ul> <li>First, there are separate functions defined for the asynchronous and synchronous portions of the callback task.</li> <li>Second, the asynchronous task happens first, and the synchronous task will not begin execution until the asynchronous task finishes.</li> <li>Third, any data returned from the asynchrounous portion of the task (such as the return statement on line 6 of the above example) is passed as a function argument to the synchronous portion of the task (<code>sync_task</code> above takes the argument <code>data</code>). This allows for synchronous processing of whatever data was retrieved in the asynchronous portion of the task.</li> </ul>"},{"location":"managers/tasks/#stopping-a-task","title":"Stopping a Task","text":"<p>There are two ways tasks can be stopped/cancelled:</p> <ol> <li>By calling the <code>cancel()</code> function on the task object itself.</li> <li>By calling the <code>stopTask</code> function of the task manager, and passing the task object to stop.</li> </ol> <p>Here is an example using the <code>cancel()</code> function on the task:</p> <pre><code>import pyspigot as ps\n\ndef run_task():\n    print('This is a repeating task.')\n\ntask = ps.scheduler.scheduleRepeatingTask(run_task, 0, 100) # (1)!\n\n# Some time passes...\n\ntask.cancel() # (2)!\n</code></pre> <ol> <li> <p>When the task is scheduled, we assign the returned task object so we can use it later to cancel the task.</p> </li> <li> <p>The task is stopped/cancelled by calling <code>cancel</code> on the task object that was created/assigned earlier.</p> </li> </ol> <p>Here is an example using the <code>stopTask</code> function of the task manager:</p> <pre><code>import pyspigot as ps\n\ndef run_task():\n    print('This is a repeating task.')\n\ntask = ps.scheduler.scheduleRepeatingTask(run_task, 0, 100) # (1)!\n\n# Some time passes...\n\nps.scheduler.stopTask(task) # (2)!\n</code></pre> <ol> <li> <p>When the task is scheduled, we assign the returned task object so we can use it later to cancel the task.</p> </li> <li> <p>The task is stopped/cancelled by calling the <code>stopTask</code> function of the task manager, passing the task object that was created earlier.</p> </li> </ol> Note <p>When a script is stopped, any tasks belonging to that script are stopped/cancelled automatically. You do not need to cancel them yourself.</p>"},{"location":"managers/tasks/#summary","title":"Summary","text":"<ul> <li>Like listeners, tasks are defined as functions in your script. Task can take any number of arguments, including zero.</li> <li>Tasks can pass arguments on to the function they call. Specify these arguments when you register your task with the task manager.</li> <li>All tasks must be registered with PySpigot's task manager. For example, to schedule and run a synchronous repeating task, use <code>scheduler.scheduleRepeatingTask(function, delay, interval, functionArgs)</code>.</li> <li>Scheduling any type of task returns a <code>Task</code> object, which can be used to cancel the task later, if desired.</li> <li>When a script is stopped, any tasks belonging to that script are stopped/cancelled automatically.</li> </ul>"},{"location":"managers/usage/","title":"PySpigot's Managers","text":"<p>PySpigot provides a variety of managers to more easily work with parts of the Bukkit/Spigot API as well as other plugins, databases, and more. For instructions on importing these into your script, see below. The current managers built into PySpigot include:</p> <ul> <li>The Script Manager, for loading and unloading scripts from within another script.</li> <li>The Listener Manager, for registering event listeners.</li> <li>The Command Manager, for registering and working with commands.</li> <li>The Task Manager, for registering a variety of repeating, delayed, and asynchronous tasks.</li> <li>The Config Manager, for working with configuration files.</li> <li>The Database Manager, to connect to and interact with SQL-type and Mongo databases.</li> <li>The Redis Manager, to connect to and interact with a Redis server instance.</li> <li>The Plugin Messaging Manager, to send and receive plugin messages.</li> </ul> <p>Also included in PySpigot are two optional managers, which are available to use if the plugin they depend on is running on the server:</p> <ul> <li>The ProtocolLib Manager, to work with ProtocolLib.</li> <li>The Placeholder Manager, to work with PlaceholderAPI.</li> </ul> <p>Managers must be imported into your script inn order for you to access them. The following table summarizes how to access managers, but read the sections below for more detail on how to import them:</p> Manager Access Via Helper Module Standalone Import Script Manager <code>pyspigot.script_manager()</code> <code>from dev.magicmq.pyspigot.manager.script import ScriptManager</code> Listener Manager <code>pyspigot.listener_manager()</code> <code>from dev.magicmq.pyspigot.manager.listener import ListenerManager</code> Command Manager <code>pyspigot.command_manager()</code> <code>from dev.magicmq.pyspigot.manager.command import CommandManager</code> Task Manager <code>pyspigot.task_manager()</code> <code>from dev.magicmq.pyspigot.manager.task import TaskManager</code> Config Manager <code>pyspigot.config_manager()</code> <code>from dev.magicmq.pyspigot.manager.config import ConfigManager</code> Database Manager <code>pyspigot.database_manager()</code> <code>from dev.nagicmq.pyspigot.manager.database import DatabaseManager</code> Redis Manager <code>pyspigot.redis_manager()</code> <code>from dev.magicmq.pyspigot.manager.redis import RedisManager</code> Protocol Manager <code>pyspigot.protocol_manager()</code> <code>from dev.magicmq.pyspigot.bukkit.manager.protocol import ProtocolManager</code> Placeholder Manager <code>pyspigot.placeholder_manager()</code> <code>from dev.magicmq.pyspigot.bukkit.manager.placeholder import PlaceholderManager</code> Plugin Messaging Manager <code>pyspigot.messaging_manager()</code> <code>from dev.magicmq.pyspigot.bukkit.manager.messaging import PluginMessagingManager</code> Warning <p>The Protocol Manager and Placeholder Manager are optional managers. These managers should only be accessed if the ProtocolLib and/or PlaceholderAPI plugins are loaded and enabled.</p>"},{"location":"managers/usage/#using-pyspigots-managers","title":"Using PySpigot's Managers","text":"<p>To utilize these managers, they must be imported into your script. This can be done in three ways:</p>"},{"location":"managers/usage/#import-managers-via-the-pyspigotpy-helper-library","title":"Import managers via the <code>pyspigot.py</code> helper library","text":"<p>PySpigot ships with a <code>pyspigot.py</code> helper module, which is included in the PySpigot JAR file. This module contains several helper functions that makes it easier to access all the managers.</p> <pre><code>import pyspigot as ps\n\nps.script_manager().&lt;function&gt;\nps.listener_manager().&lt;function&gt;\nps.command_manager().&lt;function&gt;\nps.task_manager().&lt;function&gt;\nps.config_manager().&lt;function&gt;\nps.protocol_manager().&lt;function&gt;\nps.placeholder_manager().&lt;function&gt;\nps.database_manager().&lt;function&gt;\nps.redis_manager().&lt;function&gt;\nps.messaging_manager().&lt;function&gt;\n</code></pre> <p>In the above code, the PySpigot library is imported as <code>ps</code>. Then, functions within the library are called to get each manager. Of course, you can also assign the needed managers to a variable for ease of use in multiple locations within your code, like so:</p> <pre><code>import pyspigot as ps\n\nscript = ps.script_manager()\nlistener = ps.listener_manager()\ncommand = ps.command_manager()\n...\n\nscript.&lt;function&gt;\nlistener.&lt;function&gt;\ncommand.&lt;function&gt;\n...\n</code></pre> <p>For more information and documentation on the <code>pyspigot.py</code> helper module, see the PySpigot Helper Module page.</p>"},{"location":"managers/usage/#import-each-manager-individually","title":"Import each manager individually","text":"<p>You can also import each manager class individually, directly from PySpigot's Java code.</p> <pre><code>from dev.magicmq.pyspigot.manager.script import ScriptManager as script\nfrom dev.magicmq.pyspigot.manager.listener import ListenerManager as listener\nfrom dev.magicmq.pyspigot.manager.command import CommandManager as command\nfrom dev.magicmq.pyspigot.manager.task import TaskManager as scheduler\nfrom dev.magicmq.pyspigot.manager.config import ConfigManager as config\nfrom dev.magicmq.pyspigot.manager.protocol import ProtocolManager as protocol\n\nscript.get().&lt;function&gt;\nlistener.get().&lt;function&gt;\ncommand.get().&lt;function&gt;\n...\n</code></pre> Warning <p>If importing a manager individually, <code>get()</code> must be used each time the manager is called!</p>"},{"location":"misc/api/","title":"PySpigot API","text":"<p>Work in progress. For now, see the PySpigot JavaDocs for detailed API usage.</p>"},{"location":"misc/autocomplete/","title":"Autocomplete and Code Suggestions","text":"Warning <p>Currently, this is an experimental project. If you choose to set up and use this portion of PySpigot, expect bugs and frequent changes. I will notify of any updates and changes on Discord, so be sure to join if you haven't already, to stay in the loop.</p> <p>If you're looking for instructions on how to set this up for yourself, skip down to the setup section.</p> <p>One difficulty you might encounter when writing PySpigot scripts is a lack of code suggestions and autocomplete in your IDE when you write them. The reason why these features aren't available when writing scripts is relatively straightforward - because PySpigot scripts are executed at runtime, the IDE/text editor has no idea what functions, classes, etc. you are referencing when writing scripts.</p> <p>Writing more complex scripts can quickly become cumbersome because none of the API is available, so you would need to manually look everything up, including packages, class names, functions, and API documentation. This project is aimed at smoothing out these difficulties when writing scripts.</p>"},{"location":"misc/autocomplete/#overview","title":"Overview","text":"<p>The core of this project is docs-translator, a Java program which, in very simple terms, takes documented Java source code, translates it into documented Python code, and then bundles the translated sources into an installable Python package. These Python packages can then be installed into a virtual environment, which an IDE can use.</p>"},{"location":"misc/autocomplete/#how-docs-translator-works","title":"How docs-translator Works","text":"<p>docs-translator relies heavily upon the JavaParser library, which, in the most simple terms, reads Java source (<code>.java</code>) files and turns them into an abstract syntax tree, which can be read programmatically and translated into Python source files with relative ease.</p> <p>The application runs in a stepwise fashion:</p> <ol> <li>The application initializes all working directories.</li> <li>Java source JAR files (I.E. those that follow the format <code>*-sources.jar</code>) are downloaded from remote repositories/URLs.</li> <li>The application loops through all files contained within downloaded source JAR files. When it encounters a Java soruce file (ending in <code>.java</code>), the file is parsed with JavaParser and a best effort attempt is made to translate the source file into Python code.<ul> <li>Any files not ending in <code>.java</code> are ignored.</li> </ul> </li> <li>Translated <code>.py</code> files are placed in the user-defined output folder (<code>generated</code> by default), in the appropriate package.</li> <li>An entry is added to the <code>__init__.py</code> file in the appropriate package, to allow for importing the python module as one would normally import a Java class in Jython.</li> <li>Any source files from the Java Standard Library utilized by the previously translated Java source files are also translated in the same process outlined above.</li> <li>All <code>__init__.py</code> files are generated and placed in their appropriate locations.</li> <li>Python package-related files (<code>setup.py</code>, <code>pyproject.toml</code>, <code>MANIFEST.in</code>, <code>LICENSE</code>) are generated from options specified in the <code>settings.yml</code> and are placed in the user-defined output folder (<code>generated</code> by default).</li> </ol> <p>I then build the generated python package with <code>python -m build</code>, and upload it to PyPI with <code>twine</code>. Currently, this step of the process is manual, but I am considering expanding the functionality of docs-translator to automate this step as well.</p>"},{"location":"misc/autocomplete/#setup","title":"Setup","text":"<p>Setup is relatively simple and involves creating a new Python virtual environment, installing the necessary packages from PyPI using <code>pip</code>, and then designating the virtual environment as your Python installation in your IDE of choice.</p> <p>Although this should work with any IDE, this example uses Visual Studio Code (VS Code), as this IDE is popular, free, feature-rich, and it is what I use when writing Python. I also haven't tested how well this works in other IDEs.</p>"},{"location":"misc/autocomplete/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ensure Python 3 is installed on your system, and that you are running Python 3.9 or higher. Although PySpigot only supports Python 2, Python 3 is required for this portion of the project. You can check by running:     <pre><code>python --version\n</code></pre></li> <li>An IDE of your choice. VS Code is preferred and is used in this guide.</li> <li>A project directory where your scripts and projects live. This could be the <code>PySpigot</code> plugin folder or a separate directory if you want to keep your development environment separate from your server (or your server is on a different machine).<ul> <li>This is also the preferred location for the Python virtual environment.</li> </ul> </li> </ul>"},{"location":"misc/autocomplete/#create-a-python-virtual-environment","title":"Create a Python virtual environment","text":"Note <p>While not strictly required for setting this up, creating a virtual environment is strongly recommended because the Python packages containing the translated Java sources may interfere with other native Python packages in unpredictable ways. Using a virtual environment ensures that the translated sources remain isolated from native Python packages installed globally.</p> WindowsmacOS &amp; Linux <ol> <li>Open Command Prompt (cmd) or PowerShell.</li> <li>Navigate to your project directory:     <pre><code>cd path/to/your/project/directory\n</code></pre></li> <li>Create a virtual environment with Python:     <pre><code>python -m venv venv\n</code></pre><ul> <li>Note that in the above command, the last argument is the name of the virtual environment. In this case, we're naming it <code>venv</code>.</li> </ul> </li> <li>Activate the virtual environment:<ul> <li>Command Prompt: <pre><code>venv\\Scripts\\activate\n</code></pre></li> <li>PowerShell: <pre><code>venv\\Scripts\\activate.ps1\n</code></pre> (Note: If using PowerShell, you may need to enable script execution using <code>Set-ExecutionPolicy Unrestricted -Scope Process</code>)</li> </ul> </li> <li>The virtual environment is now active, and you should see <code>(venv)</code> in the command line prompt.</li> <li>To deactivate the virtual environment:     <pre><code>deactivate\n</code></pre></li> </ol> <ol> <li>Open a terminal.</li> <li>Navigate to your project directory:     <pre><code>cd path/to/your/project/directory\n</code></pre></li> <li>Create a virtual environment with Python:     <pre><code>python -m venv venv\n</code></pre><ul> <li>Note that in the above command, the last argument is the name of the virtual environment. In this case, we're naming it <code>venv</code>.</li> </ul> </li> <li>Activate the virtual environment:     <pre><code>source venv/bin/activate\n</code></pre></li> <li>The virtual environment is now active, and you should see <code>(venv)</code> in the command line prompt.</li> <li>To deactivate the virtual environment:     <pre><code>deactivate\n</code></pre></li> </ol>"},{"location":"misc/autocomplete/#install-the-translated-sources","title":"Install the translated sources","text":"<p>As stated previously, translated sources have been bundled into Python packages and published to PyPI for convenient installation. At minimum, two packages should be installed into the virtual environment:</p> <ul> <li> <p>The translated sources of the server software you are developing for:</p> If your server runs... Then the package you should install is... Spigot pyspigot-spigot-sources Paper pyspigot-paper-sources Purpur pyspigot-purpur-sources Mohist pyspigot-spigot-sources BungeeCord pyspigot-bungee-sources <p>The version to install is the Minecraft version of your server.</p> <p>Some examples:</p> <ul> <li>If your server runs Spigot on Minecraft 1.18.2, install <code>pyspigot-spigot-sources==1.18.2</code>.</li> <li>If your server runs Paper on Minecraft 1.21.4, install <code>pyspigot-paper-sources==1.21.4</code>.</li> <li>If your server runs Purpur on Minecraft 1.20.6, install <code>pyspigot-purpur-sources==1.20.6</code>.</li> <li>If your server runs BungeeCord on Minecraft 1.19.4, install <code>pyspigot-bungeecord-sources==1.19.4</code>.</li> </ul> </li> <li> <p>The translated sources of PySpigot itself:</p> <p>Determining which PyPI package to install for the translated sources of PySpigot is much easier:</p> If your server runs... Then the package you should install is... Bukkit (Spigot, Paper, Purpur, etc.) pyspigot-sources-bukkit BungeeCord pyspigot-sources-bungee <p>The version to install is the version of PySpigot on your server.</p> <p>Some examples:</p> <ul> <li>If your server runs Bukkit and PySpigot version 0.9.1, install <code>pyspigot-sources-bukkit==0.9.1</code>.</li> <li>If your server runs BungeeCord and PySpigot version 0.9.1, install <code>pyspigot-sources-bungee==0.9.1</code>.</li> </ul> </li> </ul> <p>After you've figured out what packages you need to install, follow these steps:</p> <ol> <li>Ensure the virtual environment you created earlier is activated:<ul> <li>Verify you see <code>(venv)</code> in the command line prompt.</li> <li>Run the following:     <pre><code>where python (Windows)\nwhich python (macOS/Linux)\n</code></pre>     Verify the output includes the location where you just installed the virtual environment.</li> </ul> </li> <li>Install each package:     <pre><code>pip install pyspigot-spigot-sources==1.21.4\npip install pyspigot-sources-bukkit==0.9.1\n</code></pre> Note: These will differ depending on your server software, Minecraft version, and PySpigot version! See the above section if you aren't sure what to install.</li> <li>Verify all packages were installed correctly:     <pre><code>pip freeze\n</code></pre>     Each package you installed should be listed.</li> </ol>"},{"location":"misc/autocomplete/#configure-vs-code-to-use-the-virtual-environment","title":"Configure VS Code to use the virtual environment","text":"<ol> <li>Open VS Code and navigate to/open your project directory.<ul> <li>Windows: If you're already in the project directory from the previous step, you can type the following into Command Prompt/PowerShell to open VS Code: <pre><code>code .\n</code></pre></li> </ul> </li> <li>Open the Command Palette:<ul> <li>Windows/Linux: Ctrl + Shift + P</li> <li>macOS:  + Shift + P</li> </ul> </li> <li>Search for and select Python: Select Interpreter.</li> <li>In the list that appears, select the interpreter located inside the virtual environment you created earlier:<ul> <li>Windows: ./venv/Scripts/python.exe</li> <li>macOS/Linux: ./venv/bin/python</li> </ul> </li> <li>Ensure the selected interpreter appears in the bottom-right corner of VS Code.</li> <li>VS Code will now automatically activate the virtual environment</li> </ol> Note <p>If you write scripts for multiple server softwares and/or Minecraft versions, you must create a different virtual environment for each server software and Minecraft version. Installing translated sources for multiple different server softwares/Minecraft versions into the same virtual environment will result in conflicts and overwrites.</p> <p>That's it! Now, when you write scripts, VS Code should now give code suggestions, autocomplete suggestions, and show API documentation, since it can now pull this information from the translated sources that were installed into the virtual environment.</p>"},{"location":"misc/autocomplete/#using-type-hints-when-writing-scripts","title":"Using Type Hints When Writing Scripts","text":"<p>Type hints are useful to your IDE so that it can provide code suggestions and autocomplete in situations where types are ambiguous. These situations arise when defining functions for event listeners, commands, tasks, and other situations where PySpigot calls functions in your script from Java. For example, consider the following script that registers an event listener:</p> <pre><code>import pyspigot as ps\nfrom org.bukkit.event.player import AsyncPlayerChatEvent\n\ndef player_chat(event): # (1)!\n    print('Player sent a chat! Their message was: ' + event.getMessage())\n\nlistener = ps.listener.registerListener(player_chat, AsyncPlayerChatEvent)\n</code></pre> <ol> <li>Your IDE will have no idea what type <code>event</code> is, so it  won't be able to provide any code suggestions or autocomplete for this variable.</li> </ol> <p>Your IDE won't be able to provide code suggestions when calling <code>event.&lt;something&gt;</code> from within the <code>player_chat</code> function, because it doesn't know the type of <code>event</code>. We can add a type hint to the <code>event</code> parameter to remedy this ambiguity:</p> <pre><code>import pyspigot as ps\nfrom org.bukkit.event.player import AsyncPlayerChatEvent\n\ndef player_chat(event: \"AsyncPlayerChatEvent\"): # (1)!\n    print('Player sent a chat! Their message was: ' + event.getMessage())\n\nlistener = ps.listener.registerListener(player_chat, AsyncPlayerChatEvent)\n</code></pre> <ol> <li>Now, the IDE knows that <code>event</code> will be of type <code>AsyncPlayerChatEvent</code>, so it can now provide code suggestions based on the functions within the <code>AsyncPlayerChatEvent</code> class.</li> </ol> Note <p>Since type hints were introduced in Python 3.5, Jython won't be able to parse them. You must remove them manually before running your script. I plan to add a feature into PySpigot that removes type hints automatically when loading a script file, to make things easier on the user end.</p>"},{"location":"misc/autocomplete/#installing-additional-libraries","title":"Installing Additional Libraries","text":"<p>The beauty of this system is that sources of any Java library can be translated and installed into your virtual environment for use when writing scripts. If there is an external library you use that you would like me to translate and publish to PyPI, feel free to reach out to me on Discord.</p>"},{"location":"misc/autocomplete/#issues","title":"Issues","text":"<p>Since this is a new project, and I expect issues. If you have any, please report them either on Discord or on the docs-translator Github page.</p>"},{"location":"misc/events/","title":"PySpigot Events","text":"<p>PySpigot currently has four events that you may listen for in your plugins.</p> Note <p>It is possible that script events may fire from an asynchronous context (for example, if a script exception occurs within an asynchronous task). To check if the event is within an asynchronous context, use <code>script.isAsynchronous()</code>. This method returns <code>true</code> if the event context is asynchronous, <code>false</code> if it is not.</p>"},{"location":"misc/events/#scriptevent","title":"<code>ScriptEvent</code>","text":"<p>This is the base script event for PySpigot. This event will fire when a script is loaded, unloaded, or an exception occurs within a script. <code>ScriptExceptionEvent</code>, <code>ScriptLoadEvent</code>, and <code>ScriptUnloadEvent</code> outlined below are all subclasses of this event.</p> <p>Call <code>event.getScript()</code> to get the script associated with the event.</p>"},{"location":"misc/events/#scriptexceptionevent","title":"<code>ScriptExceptionEvent</code>","text":"<p>This event is called when an exception (either a Java or a Python exception) occurs within a script.</p> <p>This event has four methods available to use:</p> <ul> <li><code>event.getScript()</code>: Get the script that threw the exception.</li> <li><code>event.getException()</code>: Returns a <code>PyException</code> object representing the exception that was thrown.</li> <li><code>event.doReportException()</code>: Returns <code>true</code> if the exception should be logged to console and the script's log file, false if otherwise</li> <li><code>event.setReportException(boolean reportException)</code>: Set if the exception should be logged to console and the script's log file.</li> </ul>"},{"location":"misc/events/#scriptloadevent","title":"<code>ScriptLoadEvent</code>","text":"<p>This event is called when a script is loaded. The event will fire only if the script loads successfully, I.E. the <code>RunResult</code> is <code>RunResult.SUCCESS</code>.</p> <p>Call <code>event.getScript()</code> to get the script associated with the event.</p>"},{"location":"misc/events/#scriptunloadevent","title":"<code>ScriptUnloadEvent</code>","text":"<p>This event is called when a script is unloaded.</p> <p>Call <code>event.getScript()</code> to get the script associated with the event.</p>"},{"location":"misc/events/#custom-script-event","title":"Custom Script Event","text":"<p>PySpigot also includes a custom event (<code>CustomEvent</code>) that scripts may instantiate and call. This event is designed for easier interplay between scripts and plugins.</p> <p>This event can be listened for just as any other Bukkit/Spigot event normally would. It contains several methods available to use:</p> <ul> <li><code>event.getScript()</code>: Get the script that created and called this event.</li> <li><code>event.getName()</code>: Get the \"name\" of this event. This variable can be used for increased granularity of the custom event. Since multiple scripts can use this event for different purposes, the event name can be used to differentiate between different use cases.</li> <li><code>event.getData()</code>: Get the data attached to this event. This is returned as a <code>PyObject</code>, which, in most cases, can be simply casted to a Java type.</li> <li><code>event.getDataAsType(String clazz)</code>: Get the data attached to the event as an instance of the provided class name. This method is useful if you can't cast the <code>PyObject</code> data to the appropriate Java type.</li> <li><code>event.getDataAsType(Class&lt;T&gt; clazz)</code>: Get the data attached to the event as an instance of the provided class. This method is useful if you can't cast the <code>PyObject</code> data to the appropriate Java type.</li> </ul> <p><code>CustomEvent</code> also implements <code>Cancellable</code>, and thus <code>event.isCancelled()</code> and <code>event.setCancelled(boolean cancelled)</code> are available to use as well.</p> Warning <p>The <code>CustomEvent</code> should be instantiated from scripts only. Attempts to instantiate the event outside of a script context will result in an exception.</p>"},{"location":"misc/events/#type-coercion","title":"Type Coercion","text":"<p>Jython normally handles type coercion automatically when going from a Python context to a Java context. As stated previously, most Python types can be simply casted to Java types. If you can't cast, then try using one of the <code>event.getDataAsType</code> methods from <code>CustomEvent</code> to manually convert the <code>PyObject</code> to the desired type. If this doesn't work, then the types likely aren't interchangeable, and you'll need to use a different type for the data. For a complete list of Python types and their Java counterparts, see the Type Coercion page.</p>"},{"location":"misc/events/#code-example","title":"Code Example","text":"<p>Conside the following PySpigot script:</p> <pre><code>from dev.magicmq.pyspigot.event.custom import CustomEvent\nfrom org.bukkit import Bukkit\n\ndictionary = {'test': '1', 'test2': '2'} # (1)!\n\nevent = CustomEvent('test_event', dictionary) # (2)!\n\nBukkit.getPluginManager().callEvent(event) # (3)!\n</code></pre> <ol> <li> <p>Here, we create a new <code>dict</code> and populate it with some data.</p> </li> <li> <p>Here, we create a new instance of <code>CustomEvent</code>, assigning \"test_event\" for the name, and the dictionary we created previously as the data.</p> </li> <li> <p>Here, we call the event by using Bukkit's plugin manager.</p> </li> </ol> <p>Then, in a Java plugin, we could create an event listener for this event that handles the event and does something with the data attached to it:</p> <pre><code>import org.bukkit.event.Listener;\nimport org.bukkit.event.EventHandler;\nimport dev.magicmq.pyspigot.event.custom.CustomEvent\n\npublic class PluginListener implements Listener {\n\n    @EventHandler\n    public void onCustomEvent(CustomEvent event) {\n        String name = event.getName();\n        if (name.equals(\"test_event\")) { // (1)!\n            PyObject data = event.getData()\n            Map data_map = (Map) data; // (2)!\n\n            for (Object key : data_map.keySet()) { // (3)!\n                System.out.println(key + \": \" + data_map.get(key));\n            }\n        }\n    }\n}\n</code></pre> <ol> <li> <p>Here, we check if the event name is equal to \"test_event\", which is the name we assigned to the event when we called it from our script. Again, using the event name is useful if there are multiple scripts utilizing the <code>CustomEvent</code>, as scripts could set different names depending on context, and plugins could check the name as is being done here.</p> </li> <li> <p>Here, we cast the data, a <code>PyObject</code>, to a map. Since we know the data coming from this event is a python <code>dict</code>, then we can safely cast, as the Python <code>dict</code> type is equivalent to a Java <code>Map</code> in Jython.</p> </li> <li> <p>Here, we loop through each element in the map, and print the key as well as its associated value.</p> </li> </ol>"},{"location":"misc/events/#conclusion","title":"Conclusion","text":"<p>See the PySpigot JavaDocs for complete API documentation on script events.</p>"},{"location":"misc/license/","title":"License","text":""},{"location":"misc/license/#general-information","title":"General Information","text":"<p>PySpigot is a free-to-use open-source project licensed under the Apache 2.0 License, and I intend to keep it this way. The tldr; of this license is that you are free to use PySpigot for commercial and non-commercial purposes. You are also free to use, modify, and redistribute PySpigot's code, as long as you: 1) include a description of changes made, 2) include documentation of my copyright on my code, and 3) include PySpigot's license documentation in the redistribution. I'm also not liable for any damages that PySpigot causes. If you would like to do something with PySpigot but you aren't sure if it's allowed as per the license, please reach out to me.</p>"},{"location":"misc/license/#license-text","title":"License Text","text":"<p>Copyright 2025 magicmq</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"misc/license/#contact","title":"Contact","text":"<p>magicmq</p> <p>business@magicmq.dev</p> <p>My personal website</p>"},{"location":"misc/plannedfeatures/","title":"Planned Features","text":"<p>PySpigot is an evolving project. I have several features planned for future releases. This is a non-comprehensive list of features I plan on adding in the future:</p> <ul> <li> Support for autocompletion in IDE/text editor when writing scripts</li> <li> Use decorators to register listeners, commands, schedule tasks, etc.</li> <li> Add a Discord manager for easier Discord integration</li> <li> Add more example scripts</li> <li> Split documentation into multiple branches for specific documentation on Bukkit, BungeeCord, and Velocity</li> <li> Support for calling PySpigot methods from scripts with *args and *kwargs (both non-keyword and keyword arguments)</li> <li> SQLite support</li> <li> Support for scripts on Waterfall and Velocity proxy server</li> <li> Add plugin messaging manager to send/receive plugin messages</li> <li> Support for multi-file projects</li> <li> Add custom script events</li> <li> Add example script that demonstrates how to create a GUI menu</li> <li> Support for scripts on BungeeCord proxy server</li> <li> Support for MySQL, Postgres, MonogDB, redis, and other databases</li> <li> Per-script metrics (uptime, number of listeners registered, commands registered, etc.) that can be viewed via command</li> <li> Ability to create and send packets via protocol manager (through ProtocolLib)</li> <li> Allow scripts to stop themselves as well as start/stop other scripts (via script manager)</li> <li> Per-script logging (log to file as well as to console for each script)</li> <li> Overhaul access to PySpigot's managers</li> <li> \"stop\" that will be called when a script is stopped or unloaded</li> </ul>"},{"location":"misc/plannedfeatures/#feature-requests","title":"Feature Requests","text":"<p>Suggestions and contributions are always welcome! Submit an issue on PySpigot's GitHub repository.</p>"},{"location":"misc/types/","title":"Python/Java Type Coercion","text":"<p>Jython handles type coercion automatically between Java and Python. However, it is useful to know the equivalency of Python types to Java types. The following table describes the equivalency of all types available in Python to their Java counterparts.</p> Python Type Jython PyObject Subclass Java Type Description <code>int</code> <code>PyInteger</code> <code>java.lang.Integer</code> Maps Python <code>int</code> to a Java <code>Integer</code>. <code>float</code> <code>PyFloat</code> <code>java.lang.Double</code> Maps Python <code>float</code> to Java <code>Double</code>. <code>str</code> <code>PyString</code> <code>java.lang.String</code> Maps Python <code>str</code> to Java <code>String</code>. <code>bool</code> <code>PyBoolean</code> <code>java.lang.Boolean</code> Maps Python <code>True</code>/<code>False</code> to Java <code>Boolean</code> <code>None</code> <code>PyNone</code> <code>null</code> Python <code>None</code> translates to Java <code>null</code>. <code>long</code> (Python 2 only) <code>PyLong</code> <code>java.math.BigInteger</code> Maps Python <code>long</code> to <code>BigInteger</code>. <code>complex</code> <code>PyComplex</code> <code>org.python.core.PyComplex</code> Represents complex numbers. <code>list</code> <code>PyList</code> <code>java.util.List</code> Maps Python <code>list</code> to Java <code>List</code>. <code>tuple</code> <code>PyTuple</code> <code>java.util.List</code> (immutable) Maps Python <code>tuple</code> to Java <code>List</code> but immutable. <code>dict</code> <code>PyDictionary</code> <code>java.util.Map</code> Maps Python <code>dict</code> to Java <code>Map</code>. <code>set</code> <code>PySet</code> <code>java.util.Set</code> Maps Python <code>set</code> to Java <code>Set</code>. <code>frozenset</code> <code>PyFrozenSet</code> <code>java.util.Set</code> (immutable) Maps Python <code>frozenset</code> to immutable Java <code>Set</code>. <code>bytes</code> <code>PyString</code> <code>byte[]</code> Maps Python <code>bytes</code> to Java <code>byte[]</code>. <code>bytearray</code> <code>PyByteArray</code> <code>byte[]</code> Mutable version of <code>bytes</code> mapped to <code>byte[]</code> <code>memoryview</code> <code>PyMemoryView</code> <code>org.python.core.PyMemoryView</code> Maps Python <code>memoryview</code> to Java PyMemoryView. <code>function</code> <code>PyFunction</code> <code>org.python.core.PyFunction</code> Python functions map to PyFunction in Java. <code>method</code> <code>PyMethod</code> <code>org.python.core.PyMethod</code> Python methods map to PyMethod. <code>class</code> <code>PyClass</code> <code>org.python.core.PyClass</code> Represents Python classes in Java. <code>instance</code> <code>PyInstance</code> <code>org.python.core.PyInstance</code> Maps Python instances to PyInstance. <code>module</code> <code>PyModule</code> <code>org.python.core.PyModule</code> Represents Python modules in Jython. <code>callable</code> (e.g., lambdas) <code>PyCallable</code> <code>org.python.core.PyObject</code> (callable) Maps callable Python objects like lambdas. <code>object</code> (general) <code>PyObject</code> <code>java.lang.Object</code> Generic Python object maps to <code>Object</code> in Java. <code>iter</code> (iterator) <code>PyIterator</code> <code>java.util.Iterator</code> Python <code>iterator</code> maps to Java <code>Iterator</code>. <code>generator</code> <code>PyGenerator</code> <code>org.python.core.PyGenerator</code> Maps Python generator objects. <code>Exception</code> <code>PyException</code> <code>java.lang.Throwable</code> Python exceptions map to Java <code>Throwable</code>. <code>file</code> (Python 2 only) <code>PyFile</code> <code>java.io.InputStream</code>/<code>OutputStream</code> Maps Python file objects to Java IO streams. <code>ellipsis</code> (<code>...</code>) <code>PyEllipsis</code> <code>org.python.core.PyEllipsis</code> Represents the <code>...</code> object in Python. <code>NotImplemented</code> <code>PyNotImplemented</code> <code>org.python.core.PyNotImplemented</code> Represents <code>NotImplemented</code> in Python. <code>slice</code> <code>PySlice</code> <code>org.python.core.PySlice</code> Represents Python slices. <code>buffer</code> (Python 2 only) <code>PyBuffer</code> <code>org.python.core.PyBuffer</code> Represents Python buffer objects. <code>type</code> (metaclasses) <code>PyType</code> <code>org.python.core.PyType</code> Maps Python metaclasses (<code>type</code>) in Java. <code>custom objects</code> User-defined <code>PyObject</code> User-defined Java class or interface Custom Python classes map to Java <code>PyObject</code>."},{"location":"projects/projectoptions/","title":"Project Options","text":"<p>PySpigot allows you to specify project-specific options by placing a file titled <code>project.yml</code> into the project's root folder.</p> <p>Aside from the <code>main</code> option, the rest of the options outlined here are the same as regular script options.</p> Tip <p>Defining project options for each project is optional. See the Defaults section for more information.</p>"},{"location":"projects/projectoptions/#basic-format","title":"Basic Format","text":"<p>If you would like to specify options for a project, create a file named <code>project.yml</code>, and place it into the root directory of the project folder. Then, add something like this to the file:</p> <pre><code>main: 'main.py'\nenabled: true\nfile-logging-enabled: true\n</code></pre> Notice <p>The <code>project.yml</code> file must be named <code>project.yml</code>; no other names are accepted. Additionally, PySpigot searches only the root directory of the project for this file, so it must be placed there.</p>"},{"location":"projects/projectoptions/#defaults","title":"Defaults","text":"<p>Specifying project options for each project is not a requirement. PySpigot relies on fallbacks as well as default values for project options in the event that they aren't defined in the project's <code>project.yml</code> file. The following diagram illustrates the process by which PySpigot searches for project options when a project loads.</p> <pre><code>graph LR\n  A[Project loads] --&gt; B{Option present in project's project.yml?};\n  B --&gt;|Yes| C[Use option from project's project.yml]\n  B --&gt;|No| D{Default option present in config.yml?}\n  D --&gt;|Yes| E[Use default option defined in config.yml]\n  D --&gt;|No| F[Use internal default option]</code></pre> <p>PySpigot first checks if an option is present in the project's <code>project.yml</code> file. If the option isn't defined there, then it will fall back to whatever default value is defined in the <code>config.yml</code> under <code>script-option-defaults</code>. If a default option isn't specified here, then it will fall back to an internally defined default value.</p> <p>PySpigot performs this process for each project option individually.</p>"},{"location":"projects/projectoptions/#options","title":"Options","text":""},{"location":"projects/projectoptions/#main","title":"<code>main</code>","text":"<p>Specify the main module for the project. PySpigot uses this to determine which module should be executed when the project loads. This is akin to calling <code>python main.py</code> for a multi-module Python project, where <code>main.py</code> is the main module for the project.</p> <pre><code>main: 'main.py'\n</code></pre> <p>Default: <code>main.py</code></p>"},{"location":"projects/projectoptions/#enabled","title":"<code>enabled</code>","text":"<p>Specify whether a project is enabled or disabled. To disable a project, set this value to <code>false</code>.</p> <pre><code>enabled: true\n</code></pre> <p>Default: <code>true</code></p>"},{"location":"projects/projectoptions/#load-priority","title":"<code>load-priority</code>","text":"<p>Specify an integer load priority for the project. Scripts and projects are loaded in order from highest to lowest load priority. In other words, scripts/projects that have a higher load priority are loaded earlier, and scripts/projects with a lower load priority are loaded later. If multiple scripts and projects have the same load priority, they are loaded in alphabetical order.</p> <pre><code>load-priority: 1\n</code></pre> <p>Default: 1</p>"},{"location":"projects/projectoptions/#plugin-depend","title":"<code>plugin-depend</code>","text":"<p>Specify a list of plugins that this project requires to load. The project will not load if any of the plugin dependencies are not loaded and running on the server. Additionally, when a plugin is unloaded/disabled, any projects that depend on that plugin as specified under this option are automatically unloaded (if the <code>script-unload-on-plugin-disable</code> option in the <code>config.yml</code> is set to <code>true</code>).</p> <pre><code>plugin-depend: ['Citizens', 'Vault']\n</code></pre> Notice <p>If you are working with ProtocolLib or PlaceholderAPI in your project, you do not need to specify either of them here. PySpigot has built-in support for these two plugins, and the dependency management is handled internally.</p> <p>Default: None (empty list)</p>"},{"location":"projects/projectoptions/#file-logging-enabled","title":"<code>file-logging-enabled</code>","text":"<p>Specify if project file logging should be enabled for the project. If this option is <code>true</code>, a project log file will be generated, and any error messages (and print messages sent to the project's logger) will be logged to this file. If this option is <code>false</code>, no messages will be logged to a log file, but messages will still be printed to the server console.</p> <pre><code>file-logging-enabled: true\n</code></pre> <p>Default: <code>true</code></p>"},{"location":"projects/projectoptions/#min-logging-level","title":"<code>min-logging-level</code>","text":"<p>Specify the minimum logging level that should be logged to the project's log file and the console. Options can be found on the JavaDocs.</p> <pre><code>min-log-level: 'INFO'\n</code></pre> <p>Default: <code>INFO</code></p>"},{"location":"projects/projectoptions/#permissions","title":"<code>permissions</code>","text":"<p>Specify a list of permissions that the project uses. This is useful for projects that want to restrict access to certain features. This section is defined in the exact same way that permissions are defined in the <code>plugin.yml</code> file for a Bukkit plugin. See usage code example below for how to define permissions, defaults, and child permissions.</p> <pre><code>permissions:\n  permission.node.*:\n    description: 'This is a permission node'\n    default: op\n    children:\n      permission.node.child: true\n  permission.node.child:\n    description: 'This is a child permission node'\n    default: true\n  another.permission.node:\n    description: 'This is another permission node'\n    default: not op\n</code></pre> <ul> <li><code>description</code> is a description of the permission node, and this is what will be displayed in the permissions list. The default value is the name of the permission node.</li> <li><code>default</code> is the default value of the permission node, or, in other words, who should have the permission node by default. There are four possible values for <code>default</code>: </li> <li><code>op</code>: Only server operators will have the permission node by default.</li> <li><code>not op</code>: Players who are not operators will have the permission node by default.</li> <li><code>true</code>: All players will have the permission (I.E. it is a default permission).</li> <li><code>false</code>: No players will have the permission (I.E. it is not a default permission). The default value is the value of <code>default_permission</code> (outlined below).</li> <li><code>children</code> is a list of child permissions that should inherit from the parent permission. Each permission node may have children. When set to <code>true</code>, the child will inherit the parent permission.</li> </ul> <p>Default: None (no permissions defined)</p>"},{"location":"projects/projectoptions/#permission-default","title":"<code>permission-default</code>","text":"<p>Specify a default value that permissions should have, if they do not have a <code>default</code> value defined.</p> <pre><code>test.py:\n  permission-default: true\n</code></pre> <p>The allowed values for <code>permission-default</code> are <code>op</code>, <code>not op</code>, <code>true</code>, and <code>false</code>:</p> <ul> <li><code>op</code>: Only server operators will have the permission node by default.</li> <li><code>not op</code>: Players who are not operators will have the permission node by default.</li> <li><code>true</code>: All players will have the permission (I.E. it is a default permission).</li> <li><code>false</code>: No players will have the permission (I.E. it is not a default permission). </li> </ul> <p>Default: <code>op</code></p>"},{"location":"projects/writingprojects/","title":"Writing Projects","text":"<p>As of PySpigot 0.9.0, PySpigot includes support for multi-file projects.</p> <p>This page only covers key information and differences to know when writing multi-file projects as opposed to single-file scripts. For the full breadth of information on PySpigot scripts/projects, see the General Information page.</p>"},{"location":"projects/writingprojects/#basic-project-information","title":"Basic Project Information","text":"<p>Writing a PySpigot project is nearly identical to writing a multi-module Python project. Modules within a project behave in the exact same way as they do in regular Python. For example, using a module would require it to be imported first, and the variables, functions, and scope are separate for each module. In addition, import mechanics also work the exact same way (I.E. an <code>__init__.py</code> file is required in a project subfolder to make it a Python package).</p> <p>Like single-file scripts, PySpigot projects are designed to be self-contained. This means that each project is treated as a single \"bundle\", and all Python modules within the project's folder are isolated from files in another. Like single-file scripts, however, projects can interact with one another in various ways.</p> <p>PySpigot projects are placed in the <code>projects</code> folder, which can be found in PySpigot's main plugin folder. Each project must be a folder, single-file projects are not allowed (as this would be a single-file script, which should be placed in the <code>scripts</code> folder instead). All folders within the <code>projects</code> folder are considered projects, and will be loaded automatically on server start/plugin load.</p> Warning <p>Project names must be unique across other project names and single-file script names, as their names are used to identify them at runtime. For example, PySpigot could not load and run a project named <code>test_project</code> and a script named <code>test_project.py</code> simultaneously.</p>"},{"location":"projects/writingprojects/#project-options","title":"Project Options","text":"<p>There are a variety of options that can be set for each project, including its main module, whether or not it is enabled, load priority, and logging options.</p> <p>Project options are specified within the project's <code>project.yml</code> file, which is placed into the project's main directory. For example, if I had a project named <code>test_project</code>, I would place its <code>project.yml</code> file at <code>/plugins/PySpigot/projects/test_project/project.yml</code>.</p> <p>The most notable project option to be aware of is <code>main</code>, which specifies the main module of the project. PySpigot uses this to determine which module to execute when the project is loaded. If this value isn't specified in a project's <code>project.yml</code> file, or the project doesn't have a <code>project.yml</code> file at all, then the default value under the <code>script-options-default</code> section of the main <code>config.yml</code> is used, (<code>main.py</code> by default).</p> <p>All other project options are identical to the regular script options used for single-file scripts. For more information on project options, see the project options page.</p> Notice <p>Defining project options for a project is optional; projects will function normally without them, provided that the main module of the project matches the default value for this project option.</p>"},{"location":"projects/writingprojects/#project-permissions","title":"Project Permissions","text":"<p>PySpigot allows projects to define a list of permissions that they use. This is useful if a project want to restrict access to certain features. Permissions are initialized and loaded just prior to parsing and executing the main module of the project, and are removed just after a project is stopped.</p> <p>Project permissions are defined in the <code>project.yml</code> file of the project. For more information on how to define permissions, see the documentation for project options.</p>"},{"location":"projects/writingprojects/#project-loading","title":"Project Loading","text":"<p>PySpigot loads and runs all projects in the projects folder automatically on plugin load or server start. Project load order is determined by load priority, as defined in the project's <code>project.yml</code> file. Projects that don't specify a load priority will inherit the default load priority specified in the <code>script-option-defaults</code> section of the <code>config.yml</code>. Projects that have the same load priority are loaded in alphabetical order.</p> <p>Projects can also be manually loaded using <code>/pyspigot load &lt;projectname&gt;</code> if you want to load/enable a project after server start/plugin load. If you make changes to a project's files during runtime, you must reload it for changes to take effect. Reload projects with <code>/pyspigot reload &lt;projectname&gt;</code>.</p> <p>There is one config option related to loading projects:</p> <ul> <li><code>script-load-delay</code>: This is the delay, in ticks, that PySpigot will wait after server loading is completed to load scripts and projects. There are 20 server ticks in one real-world second. For example, if the value is 20, then PySpigot will wait 20 ticks (or 1 second) after the server finishes loading to load scripts and projects.</li> </ul> Notice <p>Scripts and projects are interlaced when loading. In other words, they are loaded together. This means that the load priorities of scripts and projects are compared simultaneously, and a project with a higher load priority would load earlier than a script with a lower load priority, and vice versa.</p>"},{"location":"projects/writingprojects/#project-unloading","title":"Project Unloading","text":"<p>Projects can be manually unloaded using <code>/pyspigot unload &lt;projectname&gt;</code>. Running <code>/pyspigot reload</code> will also unload a project first before loading it again (if it was running beforehand).</p>"},{"location":"projects/writingprojects/#unloading-a-project-from-within-itself","title":"Unloading A Project from Within Itself","text":"<p>Unloading a project from within itself is done in the same way as it is in regular Python, via usage of the <code>sys.exit</code> function:</p> <pre><code>import sys\n\nsys.exit(0)\n</code></pre> <p>The <code>sys.exit</code> function can be safely called from any module within the project. Internally, calling <code>sys.exit</code> raises a <code>SystemExit</code> exception. PySpigot catches this exception and performs its standard unloading tasks to unload the project that raised the exception.</p> <p>If you want to unload your project with a signal that an error occured, pass <code>1</code> to <code>sys.exit</code>. Doing so will prevent the <code>stop</code> function in the project's main module from being called on unload.</p> Warning <p>Do not use the script manager to unload a project from within itself! This will lead to unexpected bugs/issues.</p>"},{"location":"projects/writingprojects/#start-and-stop-functions","title":"Start and Stop Functions","text":"<p>The <code>start</code> and <code>stop</code> functions work in the exact same way for projects as they do for single-file scripts, with the important caveat that they must be placed in the main module of your script.</p> <p>For more detailed information, see the section on start and stop functions for single-file scripts.</p>"},{"location":"projects/writingprojects/#the-pyspigotpy-helper-module","title":"The <code>pyspigot.py</code> Helper Module","text":"<p>PySpigot ships with a helper module called <code>pyspigot.py</code> that contains various useful functions to access PySpigot's manager classes. This helper module is accessible from any module within a project via a simple import:</p> <pre><code>import pyspigot as ps\n\n...\n</code></pre> <p>For more information, see the PySpigot Helper Module page.</p>"},{"location":"projects/writingprojects/#global-variables","title":"Global Variables","text":"<p>The global variables system functions in the exact same way for projects as it does for single-file scripts.</p> <p>See the Global Variables page for detailed information on how to use the global variables system.</p>"},{"location":"projects/writingprojects/#project-errors-and-exceptions","title":"Project Errors and Exceptions","text":"<p>Errors and exceptions in projects function in the same way as they do for single-file scripts, except that for exceptions that occur in a module other than the main module of the project, the traceback will include the full call stack (with the last line being the module that caused/raised/threw the exception).</p> <p>For defailed information, see the section on script errors and exceptions for single-file scripts.</p>"},{"location":"projects/writingprojects/#project-logging","title":"Project Logging","text":"<p>Script logging for projects functions in the same way as it does for single-file scripts. For defailed information, see the section on script logging for single-file scripts.</p>"},{"location":"projects/writingprojects/#non-ascii-characters-in-project-files","title":"Non-ASCII Characters in Project Files","text":"<p>For information on how to include non-ASCII characters in project files, visit this page.</p>"},{"location":"pyspigot/plugincommands/","title":"PySpigot Commands","text":"<p>PySpigot has several commands available to use, mostly for loading, unloading, and reloading scripts. They are all documented here.</p> Tip <p>In general, when a command takes the name of a script or project, PySpigot uses the existence of a <code>.py</code> file extension in the name argument to determine if you are referencing a script or project:</p> <ul> <li>When you are referencing a single-file script, use the name of the script file, including the file extension (for example, <code>test_script.py</code>). In addition, use the name of the file only. Do not include subfolders if the script is located within a subfolder. PySpigot automatically searches the <code>scripts</code> folder for a matching script file based on the name you provide.<ul> <li>For example, if you have a script with the path <code>scripts/test/test.py</code>, you should reference it by the file name only (<code>test.py</code>). To load it, you would run the command <code>/pyspigot load test.py</code></li> </ul> </li> <li>When you are referencing a project, use the name of the project's folder (for example, <code>test_project</code>). Do not pass the main module of the project.</li> </ul>"},{"location":"pyspigot/plugincommands/#base-command","title":"Base Command","text":"<p>The base command for PySpigot is <code>/pyspigot</code>. Running this command will print a list of available commands (as long as the user that typed the command has the permission <code>pyspigot.command.listcmds</code>).</p> <ul> <li>Syntax: <code>/pyspigot &lt;argument&gt;</code></li> <li>Aliases: <code>ps</code></li> <li>Permission: <code>pyspigot.command.listcmds</code></li> </ul> <p>All commands that follow are subcommands of the base command.</p>"},{"location":"pyspigot/plugincommands/#help-command","title":"Help Command","text":"<p>Displays several helpful links, including the documentation (this site), the PySpigot plugin page on Spigot, the official Discord, and a link to report issues/bugs on GitHub.</p> <ul> <li>Syntax: <code>/pyspigot help</code></li> <li>Aliases: <code>gethelp</code></li> <li>Permission: <code>pyspigot.command.help</code></li> </ul>"},{"location":"pyspigot/plugincommands/#info-command","title":"Info Command","text":"<p>Displays detailed information about a script or project, including uptime, registered listeners, commands, tasks, and more information. If getting info about a script, pass the script's name (including <code>.py</code>). If getting info about a project, pass the project's name (the name of the project folder). If <code>.py</code> is not included in the name, PySpigot will assume the name refers to a project.</p> <ul> <li>Syntax: <code>/pyspigot info &lt;scriptname/projectname&gt;</code></li> <li>Aliases: <code>scriptinfo</code></li> <li>Permission: <code>pyspigot.command.info</code></li> </ul>"},{"location":"pyspigot/plugincommands/#listscripts-command","title":"ListScripts Command","text":"<p>Lists all scripts and projects, both unloaded and loaded. Loaded scripts and projects are shown in green; unloaded scripts and projects are shown in red. Use <code>[page]</code> to go to another page, if there are multiple pages available.</p> <ul> <li>Syntax: <code>/pyspigot listscripts [page]</code></li> <li>Aliases: <code>list</code>, <code>scriptslist</code>, <code>ls</code></li> <li>Permission: <code>pyspigot.command.listscripts</code></li> </ul>"},{"location":"pyspigot/plugincommands/#load-command","title":"Load Command","text":"<p>Loads and runs a script or project. If loading a script, pass the script's name (including <code>.py</code>). If loading a project, pass the project's name (the name of the project folder). If <code>.py</code> is not included in the name, PySpigot will assume the name refers to a project.</p> <ul> <li>Syntax: <code>/pyspigot load &lt;scriptname/projectname&gt;</code></li> <li>Aliases: <code>start</code></li> <li>Permission: <code>pyspigot.command.load</code></li> </ul>"},{"location":"pyspigot/plugincommands/#loadlibrary-command","title":"LoadLibrary Command","text":"<p>Loads a Java library that you would like to use in a script. See External Libraries for more information.</p> <ul> <li>Syntax: <code>/pyspigot loadlibrary &lt;filename&gt;</code></li> <li>Aliases: <code>loadlib</code></li> <li>Permission: <code>pyspigot.command.loadlibrary</code></li> </ul>"},{"location":"pyspigot/plugincommands/#reloadall-command","title":"ReloadAll Command","text":"<p>Performs a complete reload of PySpigot, including the <code>config.yml</code>, <code>script_options.yml</code>, the library manager, and all scripts/projects.</p> <ul> <li>Syntax: <code>/pyspigot reloadall</code></li> <li>Aliases: <code>reset</code>, <code>restart</code>, <code>reboot</code>, <code>resetall</code></li> <li>Permission: <code>pyspigot.command.reloadall</code></li> </ul>"},{"location":"pyspigot/plugincommands/#reload-command","title":"Reload Command","text":"<p>Reloads a script or project. Useful if you made changes to a script/project while it is running and you would like to reload it. If reloading a script, pass the script's name (including <code>.py</code>). If reloading a project, pass the project's name (the name of the project folder). If <code>.py</code> is not included in the name, PySpigot will assume the name refers to a project.</p> <ul> <li>Syntax: <code>/pyspigot reload &lt;scriptname/projectname&gt;</code></li> <li>Aliases: None</li> <li>Permission: <code>pyspigot.command.reload</code></li> </ul>"},{"location":"pyspigot/plugincommands/#reloadconfig-command","title":"ReloadConfig Command","text":"<p>Reloads PySpigot's <code>config.yml</code> and <code>script_options.yml</code>.</p> <ul> <li>Syntax: <code>/pyspigot reloadconfig</code></li> <li>Aliases: <code>configreload</code></li> <li>Permission: <code>pyspigot.command.reloadconfig</code></li> </ul> Warning <p>The <code>/ps reloadconfig</code> command does not reload scripts or projects! Instead, use <code>/pyspigot reload &lt;scriptname/projectname&gt;</code> to reload a script/project, or <code>/ps reloadall</code> to reload all scripts and projects.</p>"},{"location":"pyspigot/plugincommands/#unload-command","title":"Unload Command","text":"<p>Stops and unloads a script. If unloading a script, pass the script's name (including <code>.py</code>). If unloading a project, pass the project's name (the name of the project folder). If <code>.py</code> is not included in the name, PySpigot will assume the name refers to a project.</p> <ul> <li>Syntax: <code>/pyspigot unload &lt;scriptname/projectname&gt;</code></li> <li>Aliases: <code>stop</code></li> <li>Permission: <code>pyspigot.command.unload</code></li> </ul>"},{"location":"pyspigot/pluginconfiguration/","title":"PySpigot Configuration","text":"<p>The following page provides information on all configuration values that can be found in PySpigot's <code>config.yml</code>.</p>"},{"location":"pyspigot/pluginconfiguration/#metrics-enabled","title":"<code>metrics-enabled</code>","text":"<p>Specifies whether PySpigot will collect metrics data and submit this data to bStats. Set to <code>false</code> to disable collection of metrics data. You may also disable bStats server-wide in the bStats config file under <code>/plugins/bStats</code>.</p> <pre><code>metrics-enabled: true\n</code></pre> <p>Default: <code>true</code></p>"},{"location":"pyspigot/pluginconfiguration/#script-load-delay","title":"<code>script-load-delay</code>","text":"<p>The delay, in ticks, that PySpigot will wait after server loading is completed to load scripts. There are 20 server ticks in one real-world second. For example, if the value is 20, then PySpigot will wait 20 game ticks (or 1 real-world second) after the server finishes loading to load scripts. Set to <code>-1</code> to disable a load delay and load scripts immediately.</p> <pre><code>script-load-delay: 20\n</code></pre> <p>Default: <code>20</code></p>"},{"location":"pyspigot/pluginconfiguration/#library-relocations","title":"<code>library-relocations</code>","text":"<p>List of relocation rules for external Java libraries in the <code>java-libs</code> folder. This feature is useful to relocate class names of an external Java library if a different version of the library is already present and in use by another plugin on the server. Format as <code>&lt;pattern&gt;|&lt;relocated pattern&gt;</code>.</p> <pre><code>library-relocations:\n  - 'org.apache.commons|relocated.org.apache.commons'\n</code></pre> <p>Default: None (empty list)</p>"},{"location":"pyspigot/pluginconfiguration/#log-timestamp-format","title":"<code>log-timestamp-format</code>","text":"<p>The Date/time format that should be used to timestamp log messages when printing them to a script's log file. The timestamp should be in an appropriate SimpleDateFormat.</p> <pre><code>log-timestamp-format: 'MMM dd yyyy HH:mm:ss'\n</code></pre> <p>Default: <code>MMM dd yyyy HH:mm:ss</code></p>"},{"location":"pyspigot/pluginconfiguration/#script-action-logging","title":"<code>script-action-logging</code>","text":"<p>Specifies whether or not messages should be printed to console when a script is loaded, unloaded, and reloaded.</p> <pre><code>script-action-logging: true\n</code></pre> <p>Default: <code>true</code></p>"},{"location":"pyspigot/pluginconfiguration/#verbose-redis-logging","title":"<code>verbose-redis-logging</code>","text":"<p>Specifies whether all redis events should be logged to a script's logger, or if only crucial events should be logged. Crucial events include reconnect attempts and reconnect failures. If set to <code>false</code>, only these crucial events will be logged.</p> <pre><code>verbose-redis-logging: true\n</code></pre> <p>Default: <code>true</code></p>"},{"location":"pyspigot/pluginconfiguration/#script-unload-on-plugin-disable","title":"<code>script-unload-on-plugin-disable</code>","text":"<p>Specifies whether a script should be automatically unloaded if a plugin it depends on is unloaded. This value only applies to scripts that have plugin dependencies listed in the <code>script_options.yml</code> file. This feature is especially useful to ensure that when a script depends on a plugin, its shutdown tasks complete successfully if one or more of the plugins it depends on is/are disabled.</p> <pre><code>script-unload-on-plugin-disable: true\n</code></pre> <p>Default: <code>true</code></p>"},{"location":"pyspigot/pluginconfiguration/#jython-options","title":"<code>jython-options</code>","text":"<p>This section allows you to specify options that pertain to Jython.</p>"},{"location":"pyspigot/pluginconfiguration/#init-on-startup","title":"<code>init-on-startup</code>","text":"<p>Specifies whether or not Jython should be initialized on plugin load. If this is set to <code>true</code>, script load times can be reduced by initializing Jython earlier (during server startup) rather than just prior to loading the first script.</p> <pre><code>jython-options:\n  init-on-startup: true\n</code></pre> <p>Default: <code>true</code></p>"},{"location":"pyspigot/pluginconfiguration/#properties","title":"<code>properties</code>","text":"<p>A list of properties that should be passed to Jython when it is initialized. By default, the <code>python.cachedir.skip</code> property is passed with a value of <code>true</code>. Unless you know what you are doing, this option should be left as-is, as under normal circumstances, embedded Jython should not utilize a cache directory.</p> <p>See this page for a more detailed explanation as well as the RegistryKey class in the Jython source code for a complete list of Jython properties.</p> <pre><code>jython-options:\n  properties:\n    - 'python.cachedir.skip=true'\n</code></pre> <p>Default: List containing <code>python.cachedir.skip=true</code></p>"},{"location":"pyspigot/pluginconfiguration/#args","title":"<code>args</code>","text":"<p>A list of arguments that should be passed to Jython when it is initialized. This is equivalent to the <code>sys.argv</code> list in regular Python.</p> <pre><code>jython-options:\n  args:\n    - 'test_argument'\n</code></pre> <p>Default: None (empty list)</p>"},{"location":"pyspigot/pluginconfiguration/#script-option-defaults","title":"<code>script-option-defaults</code>","text":"<p>The script option defaults are default script options that can be specified. The options defined in this section serve as fallback falues that should be used in the case that a script has one or more script options that aren't defined in the <code>script_options.yml</code> file.</p>"},{"location":"pyspigot/pluginconfiguration/#main","title":"<code>main</code>","text":"<p>Specifies the main module for a project (this option is not applicable to a single-file script). PySpigot uses this to determine which module should be executed when the project loads. This is akin to calling <code>python main.py</code> for a multi-module Python project, where <code>main.py</code> is the main module for the project.</p> <pre><code>main: 'main.py'\n</code></pre> <p>Default: <code>main.py</code></p>"},{"location":"pyspigot/pluginconfiguration/#enabled","title":"<code>enabled</code>","text":"<p>Used to enable or disable a script or project. To disable a script/project, set this value to <code>false</code>.</p> <pre><code>script-option-defaults:\n  enabled: true\n</code></pre> <p>Default: <code>true</code></p>"},{"location":"pyspigot/pluginconfiguration/#load-priority","title":"<code>load-priority</code>","text":"<p>Specifies an integer load priority for the script or project. Scripts and projects are loaded in order from highest to lowest load priority. In other words, scripts/projects that have a higher load priority are loaded earlier, and scripts/projects with a lower load priority are loaded later. If multiple scripts/projects have the same load priority, they are loaded in alphabetical order.</p> <pre><code>script-option-defaults:\n  load-priority: 1\n</code></pre> <p>Default: <code>1</code></p>"},{"location":"pyspigot/pluginconfiguration/#plugin-depend","title":"<code>plugin-depend</code>","text":"<p>Specifies a list of plugins that the script or project depends on. The script/project will not load if any of the plugin dependencies are not loaded and running on the server. Additionally, if the [#script-unload-on-plugin-disable] parameter is set to <code>true</code>, any scripts/projects that depend on that plugin as specified under this option are automatically unloaded when the plugin is unloaded/disabled.</p> Note <p>If you are working with ProtocolLib or PlaceholderAPI in your script or project, you do not need to specify either of them here. PySpigot has built-in support for these two plugins, and the dependency management is handled automatically.</p> <pre><code>script-option-defaults:\n  plugin-depend:\n    - 'Citizens'\n</code></pre> <p>Default: None (empty list)</p>"},{"location":"pyspigot/pluginconfiguration/#file-logging-enabled","title":"<code>file-logging-enabled</code>","text":"<p>Specifies if script/project file logging should be enabled. If this option is <code>true</code>, a script/project log file will be generated, and any error messages (and print messages sent to the script/project's logger) will be logged to this file. If set to <code>false</code>, no messages will be logged to a log file, but messages will still be printed to the server console.</p> <pre><code>script-option-defaults:\n  file-logging-enabled: true\n</code></pre> <p>Default: <code>true</code></p>"},{"location":"pyspigot/pluginconfiguration/#min-logging-level","title":"<code>min-logging-level</code>","text":"<p>Specifies the minimum logging level that should be logged to the script/project's log file and the console. Options can be found on the JavaDocs.</p> <pre><code>script-option-defaults:\n  min-logging-level: 'INFO'\n</code></pre> <p>Default: <code>INFO</code></p>"},{"location":"pyspigot/pluginconfiguration/#permissions","title":"<code>permissions</code>","text":"<p>Specify a list of permissions that the script/project uses. This is useful for scripts or projects that want to restrict access to certain features. This section is defined in the exact same way that permissions are defined in the <code>plugin.yml</code> file for a Bukkit plugin. See usage code example below for how to define permissions, defaults, and child permissions.</p> <pre><code>test.py:\n  permissions:\n    permission.node.*:\n      description: 'This is a permission node'\n      default: op\n      children:\n        permission.node.child: true\n    permission.node.child:\n      description: 'This is a child permission node'\n      default: true\n    another.permission.node:\n      description: 'This is another permission node'\n      default: not op\n</code></pre> <ul> <li><code>description</code> is a description of the permission node, and this is what will be displayed in the permissions list. The default value is the name of the permission node.</li> <li><code>default</code> is the default value of the permission node, or, in other words, who should have the permission node by default. There are four possible values for <code>default</code>: </li> <li><code>op</code>: Only server operators will have the permission node by default.</li> <li><code>not op</code>: Players who are not operators will have the permission node by default.</li> <li><code>true</code>: All players will have the permission (I.E. it is a default permission).</li> <li><code>false</code>: No players will have the permission (I.E. it is not a default permission). The default value is the value of <code>default_permission</code> (outlined below).</li> <li><code>children</code> is a list of child permissions that should inherit from the parent permission. Each permission node may have children. When set to <code>true</code>, the child will inherit the parent permission.</li> </ul> <p>Default: None (no permissions defined)</p>"},{"location":"pyspigot/pluginconfiguration/#permission-default","title":"<code>permission-default</code>","text":"<p>Specify a default value that permissions should have, if they do not have a <code>default</code> value defined. The allowed values for <code>permission-default</code> are <code>op</code>, <code>not op</code>, <code>true</code>, and <code>false</code>:</p> <ul> <li><code>op</code>: Only server operators will have the permission node by default.</li> <li><code>not op</code>: Players who are not operators will have the permission node by default.</li> <li><code>true</code>: All players will have the permission (I.E. it is a default permission).</li> <li><code>false</code>: No players will have the permission (I.E. it is not a default permission). </li> </ul> <pre><code>script-option-defaults:\n  permission-default: 'op'\n</code></pre> <p>Default: <code>op</code></p>"},{"location":"pyspigot/pluginconfiguration/#debug-options","title":"<code>debug-options</code>","text":"<p>The configuration values in the <code>default-options</code> section are more advanced options that should only be changed if you encounter issues or would like to disable recommended features.</p>"},{"location":"pyspigot/pluginconfiguration/#print-stack-traces","title":"<code>print-stack-traces</code>","text":"<p>Specifies if full stack traces should always be printed to the server console. Normally, if a Java exception occurs, a condensed version of the Java exception along with a Python traceback are printed, but if this parameter is set to <code>true</code>, a full Java stack trace will be printed in addition to a Python traceback.</p> <pre><code>debug-options:\n  print-stack-traces: false\n</code></pre> <p>Default: <code>false</code></p>"},{"location":"pyspigot/pluginconfiguration/#show-update-messages","title":"<code>show-update-messages</code>","text":"<p>Specifies whether the plugin should show messages in console and on join (to players with the permission <code>pyspigot.admin</code>) when a newer version of PySpigot is available to download on spigotmc.org. If set to <code>false</code>, no update messages will be shown, even if a newer version of the plugin is available.</p> <pre><code>debug-options:\n  show-update-messages: true\n</code></pre> <p>Default: <code>true</code></p>"},{"location":"pyspigot/pluginconfiguration/#jython-logging-level","title":"<code>jython-logging-level</code>","text":"<p>Specifies the logging level at which the internal Jython logger logs messages. It can be useful to set this to <code>FINE</code> or <code>ALL</code> for debugging purposes, to get a better sense of what Jython is doing internally. Note that for Jython log messages to show at the appropriate level, the server-wide logging level would also need to be adjusted accordingly.</p> <pre><code>debug-options:\n  jython-logging-level: 'INFO'\n</code></pre> <p>Default: <code>INFO</code></p>"},{"location":"pyspigot/pluginconfiguration/#patch-threading","title":"<code>patch-threading</code>","text":"<p>Specifies whether or not a patch should be applied to the <code>threading</code> module on script unload. This patch is aimed at fixing a bug that occurs when using the threading module from within an asynchronous task. For more information, see this GitHub issue report. Under most circumstances, this should be set to <code>true</code>.</p> <pre><code>debug-options:\n  patch-threading: true\n</code></pre> <p>Default: <code>true</code></p>"},{"location":"pyspigot/pluginconfiguration/#example-configuration","title":"Example Configuration","text":"<p>The following example configuration contains default values for all parameters.</p> <pre><code># If false, will disable collection of metrics information by bStats for PySpigot. You may also disable bStats server-wide in the bStats config.yml under /plugins/bStats.\nmetrics-enabled: true\n# The delay for loading scripts (in ticks) after the server finishes loading.\nscript-load-delay: 20\n# List of relocation rules for libraries in the libs folder. Format as &lt;pattern&gt;|&lt;relocated pattern&gt;\nlibrary-relocations: []\n# Date/time format for timestamps in script log files, written in Java's SimpleDateFormat pattern: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/format/DateTimeFormatter.html\nlog-timestamp-format: 'MMM dd yyyy HH:mm:ss'\n# If true, will print log messages to console every time a script is loaded, run, and unloaded.\nscript-action-logging: true\n# If true, will log all redis events to the console and to a script's logger. If false, will only log reconnect events (reconnect attempts and failures)\nverbose-redis-logging: true\n# If true, scripts will be automatically unloaded if a plugin the script depends on is unloaded. This is especially useful to ensure script shutdown tasks that require a depending plugin complete successfully (prior to the plugin being unloaded).\nscript-unload-on-plugin-disable: true\n# Options that pertain to Jython. Changing options in this section requires a server restart.\njython-options:\n  # If true, the Jython runtime will be initialized during plugin load/server start. If false, the Jython runtime will not be initialized until the first script is loaded.\n  init-on-startup: true\n  # A list of system properties that will be passed to Jython. For a complete list, see https://javadoc.io/doc/org.python/jython-standalone/latest/org/python/core/RegistryKey.html\n  properties:\n    - 'python.cachedir.skip=true'\n  # A list of args to pass to Jython when initialized. Equivalent to sys.argv in Python.\n  args:\n    - ''\n# Default values for script options. If one or more options are not defined in the script_options.yml for the script, then PySpigot will fall back to these values.\nscript-option-defaults:\n  # For projects, the main script file for the project.\n  main: 'main.py'\n  # Whether the script is enabled\n  enabled: true\n  # An integer load priority for the script\n  load-priority: 1\n  # A list of plugins the script depends on\n  plugin-depend: []\n  # Whether script log messages should be logged to its respective log file\n  file-logging-enabled: true\n  # The minimum level to log to the console and to the script's log file\n  min-logging-level: 'INFO'\n  # The default permission level for permissions\n  permission-default: 'op'\n# Advanced debug options for scripts\ndebug-options:\n  # If true, will print stack traces for all script-related exceptions to the server console\n  print-stack-traces: false\n  # If true, the plugin will show messages in console and on join (to players with the permission pyspigot.admin) when a newer version of PySpigot is available to download on spigotmc.org.\n  show-update-messages: true\n  # The logging level for Jython internals. Can be useful to set this to FINE or ALL for debugging purposes. Note: the server's root logger will also need to be configured to accept debug messages for Jython's debug messages to show.\n  jython-logging-level: 'INFO'\n  # If true, PySpigot will patch the threading module on script unload (if it's being used in the script) in order to prevent the server from hanging. For more information, see https://github.com/magicmq/pyspigot/issues/18#issue-3012022678\n  patch-threading: true\n</code></pre>"},{"location":"pyspigot/pyspigot/","title":"General Information about PySpigot","text":""},{"location":"pyspigot/pyspigot/#how-does-pyspigot-work","title":"How Does PySpigot Work?","text":"<p>A standard Python installation runs CPython. CPython is an implementation of Python that runs on the C programming language. CPython is perhaps the most popular Python implementation, since it is the reference implementation of python, or, in other words, the default implementation. Several other implementations of Python exist, including Cython, IronPython, Nuitka, Numba, PyPy, and Stackless Python. PySpigot utilizes Jython, another implementation of Python.</p> <p>Just as CPython is an implementation of Python that runs on the C programming language, Jython is an implementation of Python that runs on Java. Because Minecraft also runs on Java, Jython can run within the same environment that Minecraft runs. Indeed, PySpigot ships with Jython bundled in, and it runs on top of the Minecraft server instance. Additionally, Jython supports interpretation of Python code on the fly, which is essentially how scripts are run.</p> <p>The real magic of Jython is that, because it runs within the same environment that Minecraft does, all of the code on the Minecraft side of things is fully available to Jython, and by extension, to scripts that are executed with Jython. This makes it possible to reference Java classes within the Python code. The integration is almost completely seamless. Jython also handles conversion of variables and data structures between Python and Java types automatically.</p>"},{"location":"pyspigot/pyspigot/#one-noteable-drawback-regarding-jython","title":"One Noteable Drawback Regarding Jython","text":"<p>The major drawback of Jython is that it currently only supports Python 2. Work towards a Python 3 implementation is currently ongoing over at Jython's GitHub repository.</p> <p>Regarding different avenues, other Python-Java interop projects support Python 3. One such example is Py4J, which is more akin to a \"network bridge\" between the Python and Java runtimes rather than a true Python implementation. Although it supports Python 3, Py4J would be incredibly difficult to implement as a scripting engine for Bukkit, as it relies heavily on time-consuming I/O operations and Callbacks, which would make the Minecraft server quite unstable. Additionally, Py4J would require a CPython installation (regular Python) on the same machine, a rather difficult requirement to fulfill when working within a containerized Minecraft instance (such as Pterodactyl, shared hosting providers, etc.).</p> <p>When I began this project, I looked at using several libraries, Py4J included. I came to the conclusion that, although Jython only supports Python 2, it has several key advantages over other libraries in this specific use case, including:</p> <ul> <li>It runs entirely on the JVM, making it very easy to interface with Python code from the Java side.</li> <li>It runs entirely on the JVM, which gives all Python code direct access to the entire Java classpath at runtime. Ergo, Python code has full access to Java code and vice versa.</li> <li>It does not require any external Python installation to work. Drag and drop PySpigot into your plugins folder, and you're good to go.</li> <li>And finally, it is reasonably fast (fast enough for Minecraft's standards), given that, again, it runs entirely on the JVM.</li> </ul> <p>Thus, for the foreseeable future, PySpigot will continue to utilize Jython.</p>"},{"location":"pyspigot/pyspigot/#the-pyspigot-plugin-folder","title":"The PySpigot Plugin Folder","text":"<p>The PySpigot plugin folder is the central repository where scripts, config files, libraries, and data are stored. It has the following structure:</p> <pre><code>plugins/\n\u251c\u2500 PySpigot/ # (1)!\n\u2502  \u251c\u2500 configs/ # (2)!\n|  |  \u251c\u2500 test.yml\n|  |  \u2514\u2500 ...\n\u2502  \u251c\u2500 java-libs/ # (3)!\n|  |  \u251c\u2500 lib-example.jar\n|  |  \u2514\u2500 ...\n|  \u251c\u2500 logs/ # (4)!\n|  |  \u251c\u2500 test.log\n|  |  \u2514\u2500 ...\n|  \u251c\u2500 projects/ # (5)!\n|  |  \u251c\u2500 test_project\n|  |  |  \u251c\u2500 main.py # (6)!\n|  |  |  \u251c\u2500 project.yml # (7)!\n|  |  |  \u2514\u2500 ...\n|  |  \u2514\u2500 ...\n|  \u251c\u2500 python-libs/ # (8)!\n|  |  \u251c\u2500 lib-example.py\n|  |  \u2514\u2500 ...\n|  \u251c\u2500 scripts/ # (9)!\n|  |  \u251c\u2500 test.py\n|  |  \u2514\u2500 ...\n|  \u251c\u2500 config.yml # (10)!\n|  \u2514\u2500 script_options.yml # (11)!\n\u2514\u2500 ...\n</code></pre> <ol> <li>The main plugin folder.</li> <li>The <code>configs</code> folder is where script config files and other data files (json, etc.) are stored, by default. The <code>configs</code> folder may contain subfolders for more optimal organization of a script's config and other data files.</li> <li>The <code>java-libs</code> folder is where external Java libraries should be placed. All JAR files in this folder are automatically loaded when the plugin loads.</li> <li>The <code>logs</code> folder is where script log files are stored. A script's log file will have the same name as the script (except it will end in <code>.log</code> instead of <code>.py</code>).</li> <li>The <code>projects</code> folder is where multi-file script projects should be placed. Each folder in this folder corresponds to a different project.</li> <li>Each project should have a main module. The name of the main module is configurable in the <code>project.yml</code> file for the project. If not defined in the <code>project.yml</code>, or the <code>project.yml</code> doesn't exist, then the default value (<code>main.py</code>) is used.</li> <li>The <code>project.yml</code> file is where script options and the project's main module are configured.</li> <li>The <code>python-libs</code> folder is where external Python modules should be placed. Any external Python modules (that end in <code>.py</code>) will be automatically accessible (able to be imported) from scripts.</li> <li>The <code>scripts</code> folder is where all single-file PySpigot scripts live. The <code>scripts</code> folder may contain subfolders for more optimal organization of scripts.</li> <li>This is the main <code>config.yml</code> file for PySpigot. For more detailed information on the config, see the configuration page on the documentation.</li> <li>This is the <code>script_options.yml</code> file. This is where script options for all scripts should be placed. For more detailed information on script options, see the script options page on the documentation.</li> </ol>"},{"location":"pyspigot/pyspigot/#metrics","title":"Metrics","text":"<p>PySpigot uses bStats to collect anonymous usage data for PySpigot. I use these data to inform me about PySpigot's users, including which country they are from (so that I can offer support in popular non-English languages) as well as what Minecraft and Java versions are most popular with users. bStats also collects some other useful data, including server software (Spigot, Paper, Purpur, etc.), plugin version, and number of scripts loaded. Sensitive or identifying information is not collected.</p> <p>If you would like to opt out of this feature, set <code>metrics-enabled</code> to <code>false</code> in PySpigot's config file. Alternatively, you can disable bStats server-wide by setting <code>enabled</code> to <code>false</code> in /plugins/bStats/config.yml.</p>"},{"location":"pyspigot/pyspigot/#updates","title":"Updates","text":"<p>When PySpigot is updated to a newer version, this update will be pushed to Spigot, as well as the official GitHub repository. PySpigot has an automated system that checks Spigot for any available plugin updates.  If PySpigot finds a more up to date version available on Spigot, it will send notifications in two places:</p> <ul> <li>In the console, when the plugin loads (such as on server start).</li> <li>In chat when you log into your server. This message is only displayed to players with the permission <code>pyspigot.admin</code>.</li> </ul> <p>To disable these update messages, set <code>show-update-messages</code> to <code>false</code> in the config.yml.</p> Tip <p>It is recommended that you always use the latest version of PySpigot. Because the plugin is in its early stages of development, newer versions will usually contain important bug fixes and improvements.</p>"},{"location":"pyspigot/pyspigot/#security-and-permissions","title":"Security and Permissions","text":"Inspirational Quote <p>\"With great power comes great responsibility.\" - Uncle Ben to Peter Parker, Spider-Man</p> <p>PySpigot is an incredibly powerful plugin, and with such power, much damage could be done. Unlike other plugins, PySpigot is virtually unlimited in what it can access and in what it can do on the server. Therefore, you are advised to use extreme caution when deciding who to grant permissions to. This includes permissions to write scripts, load scripts, and unload scripts. See the next section for a list of permissions PySpigot defines as well as a description of each.</p> <p>PySpigot does not include any security safeguards outside of required permissions to use commands, so judicious usage of the plugin is advised.</p>"},{"location":"pyspigot/pyspigot/#permissions","title":"Permissions","text":"Permission Description <code>pyspigot.admin</code> If a plugin update is available, users with this permission will be shown an update message on login. <code>pyspigot.command.listcmds</code> Grants permission to list all possible subcommands of <code>/pyspigot</code>. <code>pyspigot.command.help</code> Grants permission to use the <code>/pyspigot help</code> command. <code>pyspigot.command.info</code> Grants permission to use the <code>/pyspigot info</code> command. <code>pyspigot.command.listscripts</code> Grants permission to use the <code>/pyspigot listscripts</code> command. <code>pyspigot.command.load</code> Grants permission to use the <code>/pyspigot load</code> command. <code>pyspigot.command.loadlibrary</code> Grants permission to use the <code>/pyspigot loadlibrary</code> command. <code>pyspigot.command.reloadall</code> Grants permission to use the <code>/pyspigot reloadall</code> command. <code>pyspigot.command.reload</code> Grants permission to use the <code>/pyspigot reload</code> command. <code>pyspigot.command.reloadconfig</code> Grants permission to use the <code>/pyspigot reloadconfig</code> command. <code>pyspigot.command.unload</code> Grants permission to use the <code>/pyspigot unload</code> command."},{"location":"pyspigot/quickstart/","title":"Quick Start Guide","text":"<p>Here is a very brief guide for creating your very first PySpigot script. If you don't know Python, that's okay! There are many great online tutorials to learn. See the Helpful Resources page for some good Python tutorials.</p>"},{"location":"pyspigot/quickstart/#download-and-load-pyspigot","title":"Download and Load PySpigot","text":"<p>PySpigot is officially supported on Spigot and Paper and on Minecraft versions 1.16 and newer. I cannot guarantee that PySpigot will work outside of these conditions, but some users report success on other server softwares and/or older MC versions.</p> <p>Note that more recent versions of PySpigot work only on versions of Java: - Prior to version 0.6.0, Java 12+ is required. - From version 0.6.0 to version 0.9.0, Java 17+ is required. - From version 0.9.1 onwards, Java 21+ is required.</p> <p>Download the latest version of PySpigot from GitHub or from Spigot. Drop the downloaded Jar file into your plugins folder and start your server.</p>"},{"location":"pyspigot/quickstart/#creating-your-first-script","title":"Creating Your First Script","text":"<p>In this brief tutorial, we will create a very simple script that broadcasts a message to online players.</p>"},{"location":"pyspigot/quickstart/#create-script-file","title":"Create Script File","text":"<p>All single-file scripts should be placed in the <code>scripts</code> folder within PySpigot's main plugin folder. PySpigot allows for creation of subfolders within the scripts folder for organizational purposes, but script names must be unique across all subfolders and across projects (I.E. a script and a project can't share the same name).</p> <p>Create a Python script file in the <code>scripts</code> folder, and name it whatever you would like. Make sure it ends in <code>.py</code>. The file name serves as the name for that script, which will be used to load and unload the script later.</p> Tip <p>PySpigot will only load and run script files that end in <code>.py</code>. You can easily disable a script without deleting it by changing the file extension (for example, by adding <code>.disabled</code> to the end of the file). You can also disable a script in its script options</p>"},{"location":"pyspigot/quickstart/#write-the-script","title":"Write The Script","text":"<p>Using the text editor of your choice, open the script file you just created, and write some code:</p> <pre><code>from org.bukkit import Bukkit # (1)!\n\nBukkit.broadcastMessage('Hello world!') # (2)!\n</code></pre> <ol> <li>Here, we import the <code>Bukkit</code> class from the Bukkit/Spigot API so that we can reference (use) it later in our script.</li> <li>Here, we use a function from the <code>Bukkit</code> class called <code>broadcastMessage</code>. This function broadcasts a message (string) to all players on the server in the server chat.</li> </ol> <p>Save the file, and start your server.</p>"},{"location":"pyspigot/quickstart/#run-the-script","title":"Run the Script","text":"<p>If you did everything correctly, the script should automatically load on server start. This is expected; PySpigot will automatically load and run all scripts in the <code>scripts</code> folder when the plugin loads, including any scripts within subfolders.</p> <p>Alternatively, if the server is already running and the PySpigot plugin is loaded and enabled, you can load and run the script with <code>/pyspigot load &lt;scriptname&gt;</code>. Make sure the name includes the extension (<code>.py</code>)! If the script is located in a subfolder, you don't need to specify the entire path. You only need to specify the script file name.</p> <p>If you did everything correctly, you should see the message \"Hello world!\" in the chat when the script loads.</p>"},{"location":"pyspigot/quickstart/#next-steps","title":"Next Steps","text":"<p>Check out the rest of the documentation for more advanced scripting.</p> <p>If you find yourself stuck and need help, join PySpigot's Discord server if you haven't already.</p>"},{"location":"pyspigot/quickstartproject/","title":"Quick Start Guide for Projects","text":"<p>Here is a very brief guide for creating your very first PySpigot project.</p>"},{"location":"pyspigot/quickstartproject/#download-and-load-pyspigot","title":"Download and Load PySpigot","text":"<p>PySpigot is officially supported on Spigot and Paper and on Minecraft versions 1.16 and newer. I cannot guarantee that PySpigot will work outside of these conditions, but some users report success on other server softwares and/or older MC versions.</p> <p>Note that more recent versions of PySpigot work only on newer versions of Java: - Prior to version 0.6.0, Java 12+ is required. - From version 0.6.0 to version 0.9.0, Java 17+ is required. - From version 0.9.1 onwards, Java 21+ is required.</p> <p>Download the latest version of PySpigot from GitHub or from Spigot. Drop the downloaded Jar file into your plugins folder and start your server.</p>"},{"location":"pyspigot/quickstartproject/#creating-your-first-script","title":"Creating Your First Script","text":"<p>In this brief tutorial, we will create a very simple project that registers an event listener</p>"},{"location":"pyspigot/quickstartproject/#create-the-project-folder","title":"Create The Project Folder","text":"<p>All projects should be placed in the <code>projects</code> folder of the PySpigot main plugin folder. Each folder within this main <code>projects</code> folder is treated as a separate project. All projects must have unique names among other projects and single-file scripts (I.E. a script and a project can't share the same name).</p> <p>Create a folder within the <code>projects</code> folder, and name it whatever you would like. The folder name serves as the name for that project, which will be used to load and unload the project later.</p> Tip <p>PySpigot will attempt to load all folders within the <code>projects</code> folder (as separate projects). You can disable a project by setting <code>enabled: false</code> in its project options</p>"},{"location":"pyspigot/quickstartproject/#create-a-projectyml","title":"Create a <code>project.yml</code>","text":"<p>While not required, it's strongly recommended to create a <code>project.yml</code> file inside the root folder of the project. This file serves as the source of project options for the project, where project-specific options are placed. PySpigot requires that the file be named <code>project.yml</code> and that it be in the root directory of the project.</p> <p>Create a file called <code>project.yml</code> and place it in the folder you created in the previous step.</p> <p>Using the text editor of your choice, open the file you just created, and add the following:</p> <pre><code>main: 'main.py' # (1)!\n</code></pre> <ol> <li>This directive tells PySpigot which file in our project is the \"main\" module, so it knows which module to execute when the project is loaded.</li> </ol>"},{"location":"pyspigot/quickstartproject/#create-the-listener-module","title":"Create The Listener Module","text":"<p>Next, create a Python module in the root folder of the project, and name it <code>listener.py</code>.</p> <p>Using the text editor of your choice, open the <code>listener.py</code> module, and add some code:</p> <pre><code>import pyspigot as ps # (1)!\nfrom org.bukkit.event.player import AsyncPlayerChatEvent # (2)!\n\ndef chat_event(event): # (3)!\n    print(event.getMessage()) # (4)!\n\ndef register_events(): # (5)!\n    ps.listener_manager().registerListener(chat_event, AsyncPlayerChatEvent) # (6)!\n</code></pre> <ol> <li>First, we import the pyspigot helper module.</li> <li>Next, we import the event we want to listen to, <code>AsyncPlayerChatEvent</code> in this case.</li> <li>Next, we define a function that serves as the actual listener for the event. When the event fires, this function will be called. An AsyncPlayerChatEvent object will be passed to the event containing data related to the event that occurred.</li> <li>On this line, we print to console the chat message that was sent.</li> <li>Here, we create a function that we can call from the main module of the project to register the event listener.</li> <li>Here register our event with PySpigot's listener manager, passing the function we defined earlier, as well as the event we want to listen to.</li> </ol> <p>Save the file and exit.</p>"},{"location":"pyspigot/quickstartproject/#create-the-main-module","title":"Create The Main Module","text":"<p>Lastly, create another Python module in the root folder of the project, and name it <code>main.py</code>.</p> <p>Using the text editor of your choice, open the <code>main.py</code> module, and add some code:</p> <pre><code>import listener # (1)!\nfrom org.bukkit import Bukkit # (2)!\n\nlistener.register_events() # (3)!\nBukkit.broadcastMessage('Registered event listener!') # (4)!\n</code></pre> <ol> <li>First, we import the listener module created in the previous step.</li> <li>Next, we import the <code>Bukkit</code> class to broadcast a message.</li> <li>Next, we call the function <code>register_events</code> in the listener module to register the listener set up previously.</li> <li>On this line, we broadcast a message to the server with the <code>broadcastMessage</code> function informing that the listener was registered.</li> </ol>"},{"location":"pyspigot/quickstartproject/#running-the-project","title":"Running The Project","text":"<p>If you did everything correctly, the project should automatically load on server start. This is expected; PySpigot will automatically load and run all scripts and projects in the <code>scripts</code> and <code>projects</code> folders when the plugin loads.</p> <p>Alternatively, if the server is already running and the PySpigot plugin is loaded and enabled, you can load and run the project with <code>/pyspigot load &lt;projectname&gt;</code>, passing the name of the root project folder as <code>projectname</code>.</p> <p>Verify that the project is loaded and running and has a listener registered for <code>AsyncPlayerChatEvent</code> with the command <code>/pyspigot info &lt;projectname&gt;</code>.</p>"},{"location":"pyspigot/quickstartproject/#next-steps","title":"Next Steps","text":"<p>Check out the rest of the documentation for more advanced scripting.</p> <p>If you find yourself stuck and need help, join PySpigot's Discord server if you haven't already.</p>"},{"location":"scripts/customevents/","title":"Custom Script Events","text":"<p>PySpigot includes a custom event, called <code>CustomEvent</code>, which can be used to create and call a custom event from within a script when something occurs. This event is designed for scripts to signal an event to other scripts and plugins when a specific event occurs. </p> <p>The event includes a <code>data</code> variable, set when the event is created, that allows the script to pass any type of data to listeners that are listening to the event. Also included is a <code>name</code> variable, that allows for greater specificity for listeners when multiple scripts are utilizing the <code>CustomEvent</code> simultaneously.</p> <p>PySpigot also automatically attaches the script that created and called the event to the event itself, so that listeners can determine which script called the event.</p> <p>The following describes how to use this custom event.</p>"},{"location":"scripts/customevents/#utilizing-the-custom-event","title":"Utilizing the Custom Event","text":""},{"location":"scripts/customevents/#importing-the-custom-event","title":"Importing the Custom Event","text":"<p>When running PySpigot on Spigot/Paper, the <code>CustomEvent</code> class is accessible via <code>dev.magicmq.pyspigot.bukkit.event.custom.CustomEvent</code>:</p> <pre><code>from dev.magicmq.pyspigot.bukkit.event.custom import CustomEvent\n</code></pre> <p>On the BungeeCord platform, it is accessible via <code>dev.magicmq.pyspigot.bungee.event.custom.CustomEvent</code>.</p>"},{"location":"scripts/customevents/#creating-the-custom-event","title":"Creating the Custom Event","text":"<p><code>CustomEvent</code> is an object that has three parameters associated with it that can be set when an instance of it is created:</p> <ul> <li><code>name</code>: The name of the event. Usually, this should be a specific name that an event listener can use to differentiate between multiple <code>CustomEvent</code> events coming from different scripts.</li> <li><code>data</code>: The data attached to the event. The code example below creates some dummy data for this, but typically this will be some useful data related to the event that an event listener can utilize.<ul> <li>Any Python type can be used for the <code>data</code> parameter; no type conversion is required.</li> </ul> </li> <li><code>async</code> (optional): If your event is being created and called from an asynchronous context (such as from within an asynchronous task), this should be set to <code>True</code>. Otherwise, it can be ommitted or set to <code>False</code>.</li> </ul> <pre><code>from dev.magicmq.pyspigot.event.custom import CustomEvent\n\ndictionary = {'test': '1', 'test2': '2'}\n\n# Create the custom event with the dictionary as the data\nevent = CustomEvent('script1_event', dictionary)\n</code></pre> <p>If in an asynchronous context, the event should be created like so:</p> <pre><code>from dev.magicmq.pyspigot.event.custom import CustomEvent\n\ndictionary = {'test': '1', 'test2': '2'}\n\n# Create the custom event with the dictionary as the data\nevent = CustomEvent('script1_event', dictionary, True)\n</code></pre>"},{"location":"scripts/customevents/#calling-the-custom-event","title":"Calling the Custom Event","text":"<p>The event is called with Bukkit's plugin manager, which is accessible via the <code>Bukkit</code> class (<code>org.bukkit.Bukkit</code>):</p> <pre><code>from org.bukkit import Bukkit\n\n...\n\nBukkit.getPluginManager().callEvent(event)\n</code></pre>"},{"location":"scripts/customevents/#code-example","title":"Code Example","text":"<p>Putting it all together, here is a functional example:</p> <pre><code>from dev.magicmq.pyspigot.event.custom import CustomEvent # (1)!\nfrom org.bukkit import Bukkit # (2)!\n\ndictionary = {'test': '1', 'test2': '2'} # (3)!\n\nevent = CustomEvent('script1_event', dictionary) # (4)!\n\nBukkit.getServer().getPluginManager().callEvent(event) # (5)!\n</code></pre> <ol> <li> <p>Here, we import the <code>CustomEvent</code> class.</p> </li> <li> <p>Here, we import the <code>Bukkit</code> class.</p> </li> <li> <p>Here, we create a dummy dictionary object that will serve as our data for the event.</p> </li> <li> <p>Here, we create a new instance of the <code>CustomEvent</code>, and pass it a specific name (\"script1_event\" in this case), as well as the dictionary data we created earlier.</p> </li> <li> <p>Here, we call the event with Bukkit's plugin manager, by passing the <code>CustomEvent</code> object we created earlier to <code>callEvent()</code>.</p> </li> </ol>"},{"location":"scripts/customevents/#listening-to-the-custom-event","title":"Listening to the Custom Event","text":"<p>Listening to the custom event is done in the same way as you would listen to any other Bukkit/Spigot event. The <code>CustomEvent</code> class itself has multiple functions available to use:</p> <ul> <li><code>event.getScript()</code>: Get the script that created and called this event.</li> <li><code>event.getName()</code>: Get the name of the event.</li> <li><code>event.getData()</code>: Get the data attached to the event. This is returned as a <code>PyObject</code>, which can be used directly from within a script without any type coercion.</li> <li><code>event.getDataAsType(String clazz)</code>: Get the data attached to the event as an instance of the provided class name. This method is useful if you can't cast the <code>PyObject</code> data to the appropriate Java type.</li> <li><code>event.getDataAsType(Class&lt;T&gt; clazz)</code>: Get the data attached to the event as an instance of the provided class. This method is useful if you can't cast the <code>PyObject</code> data to the appropriate Java type.</li> </ul> <p>The <code>CustomEvent</code> is also cancellable, which means a listener may cancel the event if desired.</p>"},{"location":"scripts/customevents/#summary","title":"Summary","text":"<ul> <li>The <code>CustomEvent</code> class allows scripts to signal events to other scripts or plugins, with support for passing custom <code>data</code> and specifying an event <code>name</code>.</li> <li>Creating the <code>CustomEvent</code> accepts multiple parameters: <code>name</code> (event identifier), <code>data</code> (any Python type), and <code>async</code> (optional, for asynchronous contexts).</li> <li>Call the event by using Bukkit's plugin manager via <code>Bukkit.getPluginManager().callEvent(event)</code>.</li> <li>Other scripts and plugins can listen for <code>CustomEvent</code> in the same way as any other Bukkit/Spigot event. Key event functions include <code>getScript()</code> (returns the calling script), <code>getName()</code> (returns the event name), and <code>getData()</code> (returns the data attached to the event).</li> </ul>"},{"location":"scripts/examples/","title":"Example Scripts","text":"<p>Below is a curated list of example scripts that perform various functions. You are free to use any code from any of these examples. In addition to the examples below, there are additional code snippets and code examples available on the PySpigot Discord.</p> <ul> <li><code>clearinventory.py</code>: Registers a command that clears the player's inventory.</li> <li><code>communitychest.py</code>: Adds a community chest command that opens an inventory where players can place items to share with the rest of the server.</li> <li><code>gameoflife.py</code>: Plays Conway's Game of Life in Minecraft.</li> <li><code>joinmessage.py</code>: Displays notifications when a player joins the server.</li> <li><code>kickcommand.py</code>: Registers a simple command to kick a player from the server.</li> <li><code>periodicmessage.py</code>: Creates a task that automatically sends a message to all online players every five seconds.</li> <li><code>ping.py</code>: Adds an audible ping when a player's name is mentioned in chat; ping is also toggleable via command.</li> <li><code>protocollib.py</code>: A script that utilizes a ProtocolLib chat packet listener to prevent players from sending chat messages unless if they have permission.</li> <li><code>placeholder.py</code>: A very brief script that demonstrates how to register a placeholder with PlaceholderAPI.</li> <li><code>teleport.py</code>: Creates a clickable GUI inventory, accessible via <code>/teleportgui</code>, for teleporting to different locations.<ul> <li>There is a configuration file that accompanies this script; it can be found here.</li> </ul> </li> <li><code>swearfilter.py</code>: Creates a chat listener that filters swear words out of chat messages and replaces them with asterisks (*).</li> </ul> Info <p>Do you have a script you would like to showcase as an example script? Please get in touch with me!</p>"},{"location":"scripts/externallibraries/","title":"Using External Java/Python Libraries","text":"<p>PySpigot allows you to use external Python and Java libraries when writing scripts. There are many open-source Python and Java libraries that simplify or otherwise hasten code writing. The Apache Commons Libraries, a collection of Java utility libraries that provide an abundance of useful utility functions, are one such example.</p> <p>Of course, a more advanced usage of this functionality might include writing your own external libraries for frequently used or complicated code. See the Handy Usage of External Python Modules section below for more information on this.</p>"},{"location":"scripts/externallibraries/#general-information","title":"General Information","text":"<p>PySpigot will create two folders (if they don't already exist) called <code>python-libs</code> and <code>java-libs</code> when it loads, where external libraries should be placed. This should be self-explanatory, but to clarify, external Python modules go in the <code>python-libs</code> folder, and external Java libraries go in the <code>java-libs</code> folder.</p> <p>PySpigot also ships with two helper modules:</p> <ul> <li>The <code>pyspigot.py</code> helper module, which makes it easier to access PySpigot's managers from your script.</li> <li>The <code>function.py</code> helper module, which wraps several functional interfaces in the <code>java.util.function</code> package, to make it easier to work with libraries that utilize functional interfaces (such as NBT-API).</li> </ul> <p>Both of these modules are bundled into the PySpigot JAR file, and are accessible via a simple import.</p>"},{"location":"scripts/externallibraries/#external-python-libraries","title":"External Python Libraries","text":"<p>PySpigot currently supports the usage of a single-module file for use as an external library. Currently, fully-fledged libraries/packages (I.E. those with an <code>__init__.py</code>) are not supported, but support for these is planned in a future release. Thus, from this point onwards, \"external Python library\" will be referred to as module.</p>"},{"location":"scripts/externallibraries/#loading-and-using-an-external-python-module","title":"Loading and Using an External Python Module","text":"<p>Using an external Python module is relatively simple and does not require usage of one of PySpigot's managers or any commands, unlike Java libaries. The external Python module you plan to use should be a single <code>.py</code> file. To use it, drag and drop it into the <code>python-libs</code> folder within PySpigot's main plugin folder. Then, simply <code>import</code> the module into your script, and you're good to go.</p> Tip <p>Adding new modules or deleting old modules does not require a server restart or plugin reload. However, if the code of a module is changed, all scripts that use said module should be reloaded.</p>"},{"location":"scripts/externallibraries/#handy-usage-of-external-python-modules","title":"Handy Usage of External Python Modules","text":"<p>Suppose there is a certain piece of code that you use frequently, across multiple scripts. This code could be something like converting a player's location to a config-friendly <code>dict</code>, formatting an <code>str</code>, or sending a player a message in a neat format. Instead of writing the same code multiple times across different scripts, you might consider breaking this code out into its own external Python module, then add it to the <code>python-libs</code> folder, so that you can access it from all your scripts.</p>"},{"location":"scripts/externallibraries/#external-java-libraries","title":"External Java Libraries","text":"<p>Under normal circumstances, a Java library would be \"shaded\" into a Bukkit/Spigot plugin (with the end result sometimes called a \"fat\" Jar or \"Uber\" Jar) so that the plugin has access to the dependency at runtime. We obviously can't do this with scripts.</p> <p>Instead, we can take advantage of Jython's capabilities. As stated before elsewhere in the documentation, Jython provides access to all loaded Java classes at runtime. Therefore, a collection of Java classes (the library) can be manually loaded into the classpath at runtime, which in turn gives scripts access to those classes. PySpigot's LibraryManager provides this functionality.</p> <p>When a JAR library is loaded, PySpigot creates a copy of the library that ends with \"-relocated\". For example, the library <code>jython-annotation-tools-0.9.0.jar</code> is copied to <code>jython-annotation-tools-0.9.0-relocated.jar</code>. This is done not only to accommodate relocation rules (see the section on relocation rules below), but also to speed up loading of external libraries in future plugin loads. This behavior occurs even if you don't specify any relocation rules for the library.</p>"},{"location":"scripts/externallibraries/#loading-and-using-java-libraries","title":"Loading and Using Java Libraries","text":"Warning <p>It's possible that another plugin on the server is already using the library/dependency that you'd like to use. You should check if this is the case before you attempt to load the library yourself. You can do this by trying to <code>import</code> the dependency into your script. If you're able to import it, stop here! You won't need to load it yourself, as it is already loaded (likely by another plugin).</p> <p>All Java libraries/dependencies should have a Jar file available for download somewhere, perhaps on its Github repository or on its official website. You may need to download it manually from the repository where the dependency is hosted. If you can't find the Jar file, reach out on PySpigot's Discord for help.</p> <p>Once you have the physical Jar file for the dependency you'd like to use, drag and drop it into the <code>java-libs</code> folder of the main PySpigot plugin folder. The dependency will be loaded when the PySpigot plugin is loaded and enabled (on server startup). From here, you can use <code>import</code> statements in your script to import the desired code from the library.</p> Tip <p>All Jar files present in the <code>java-libs</code> folder are loaded on plugin load (when the server starts). Loading new Jar files while PySpigot is already running requires usage of a command (see below), or a complete reload of the plugin (<code>/ps reloadall</code>).</p>"},{"location":"scripts/externallibraries/#loading-a-java-library-when-pyspigot-is-already-running","title":"Loading a Java library when PySpigot is already running","text":"<p>Like before, obtain the Jar file for the library you would like to use. Then, drag and drop it into the <code>java-libs</code> folder of the main PySpigot plugin folder.</p> <p>Next, you'll need to load the library manually with the command <code>/ps loadlibrary &lt;filename&gt;</code>, where <code>&lt;filename&gt;</code> is the name of the Jar file you are loading. Be sure to include the <code>.jar</code> extension in the file name. This will import the library.</p> <p>The library should now be loaded, and you can use <code>import</code> statements to import the desired code.</p> Notice <p>PySpigot does not have a way to unload previously loaded libraries due to limitations within Java's class loading system. Nevertheless, a library will not be loaded more than once; if it already loaded, PySpigot will not load it again.</p>"},{"location":"scripts/externallibraries/#jar-relocation-rules","title":"Jar Relocation Rules","text":"<p>You may need to change the name/classpath of classes within a library/dependency. This is called \"relocation\". There are many reasons why you might want to do this, but that is beyond the scope of this documentation. If you need to relocate a classpath of your library/dependency, you'll likely know that you need to do so already. In that case, read on for information on how to specify relocation rules.</p> <p>Within PySpigot's <code>config.yml</code>, you'll find a <code>library-relocations</code> value. You may specify your own relocations rules here. Relocation rules should be in the format <code>&lt;path&gt;|&lt;relocated-path&gt;</code>. For example, to relocate <code>com.apache.commons.lang3.stringutils</code> to <code>lib.com.apache.commons.lang3.stringutils</code>:</p> <pre><code>...\n# List of relocation rules for libraries in the libs folder. Format as &lt;pattern&gt;|&lt;relocated pattern&gt;\nlibrary-relocations:\n  - 'com.apache.commons.lang3.stringutils|lib.com.apache.commons.lang3.stringutils'\n...\n</code></pre> <p>An abbreviated list form is also permitted in YAML syntax:</p> <pre><code>...\n# List of relocation rules for libraries in the libs folder. Format as &lt;pattern&gt;|&lt;relocated pattern&gt;\nlibrary-relocations: ['com.apache.commons.lang3.stringutils|lib.com.apache.commons.lang3.stringutils']\n...\n</code></pre> <p>To add multiple relocation rules in the abbreviated list form, separate each with a comma.</p> Tip <p>As stated previously, PySpigot creates a copy that ends with \"-relocated\" of every external JAR library. This file represents the relocated JAR, with all relocation rules applied to it. This copy is only created once, or, put differently, relocation rules are only applied once. In subsequent plugin loads, the relocated JAR library is loaded.</p> <p>Therefore, if changes are made to the relocation rules, it is necessary to delete the \"-relocated.jar\" copy of the relevant library/libraries so that the updated relocation rules are applied.</p>"},{"location":"scripts/externalresources/","title":"PySpigot Resources","text":"<ul> <li>Spigot Plugin Page</li> <li>View PySpigot on GitHub</li> <li>View the JavaDocs for PySpigot</li> </ul>"},{"location":"scripts/externalresources/#external-resources","title":"External Resources","text":"<p>Here are some excellent resources you should check out for help with writing PySpigot scripts:</p> <ul> <li>Spigot/Bukkit JavaDocs</li> <li>Java API Specification</li> <li>Jython</li> <li>Jython Documentation</li> <li>There are several publicly-available online Python syntax checkers, here are a few:<ul> <li>pythonchecker.com</li> <li>extendclass.com</li> <li>online-ide.com</li> </ul> </li> </ul> <p>If you're working with ProtocolLib, here are some useful resources:</p> <ul> <li>ProtocolLib Plugin Page</li> <li>ProtocolLib GitHub (brief documentation here)</li> <li>ProtocolLib JavaDocs</li> <li>Brief tutorial on using ProtocolLib</li> </ul> <p>If you're working with PlaceholderAPI, here are some useful resources:</p> <ul> <li>PlaceholderAPI Plugin page</li> <li>PlaceholderAPI Documentation</li> <li>PlaceholderAPI JavaDocs</li> </ul>"},{"location":"scripts/externalresources/#discord","title":"Discord","text":"<p>PySpigot has its very own Discord server! Join the Discord if you're stuck and need help and/or you want to stay in the loop about updates/changes.</p>"},{"location":"scripts/externalresources/#new-to-python-check-out-these-great-tutorials-to-get-started","title":"New to Python? Check out these great tutorials to get started:","text":"<ul> <li>https://www.learnpython.org/</li> <li>https://www.w3schools.com/python/</li> <li>The Python Wiki also has a list of great tutorials to learn.</li> </ul>"},{"location":"scripts/externalresources/#for-developers","title":"For Developers","text":"<ul> <li>PySpigot Javadocs</li> </ul>"},{"location":"scripts/functionmodule/","title":"The <code>function.py</code> Helper Module","text":"<p>For convenience, PySpigot includes a helper module called <code>function.py</code>. This module wraps several functional interfaces contained within the <code>java.util.function</code> package into a Python-friendly format.</p> <p>This module makes it significantly easier to work with Java's functional interfaces when Java APIs/libraries utilize them. For example, NBT-API makes heavy use of functional interfaces, and the <code>function.py</code> helper module makes it much less cumbersome. See the usage example section for an example of how to use this module with NBT-API.</p>"},{"location":"scripts/functionmodule/#code","title":"Code","text":"<pre><code>\"\"\"\nThis is a helper module that wraps a variety of functional interfaces in the java.util.function package, for easier use in Python.\n\nThis module should be particularly useful when working with some libraries that make use of functional interfaces (such as NBT-API).\n\"\"\"\nimport java.util.function.BiConsumer\nimport java.util.function.BiFunction\nimport java.util.function.BiPredicate\nimport java.util.function.Consumer\nimport java.util.function.Function\nimport java.util.function.Predicate\nimport java.util.function.Supplier\n\n\"\"\"\nRepresents an operation that accepts two input arguments and returns no result. This is the two-arity specialization of Consumer. Unlike most other functional interfaces, BiConsumer is expected to operate via side-effects.\n\"\"\"\nclass BiConsumer(java.util.function.BiConsumer):\n\n    \"\"\"\n    Initialize a new BiConsumer.\n\n    Arguments:\n        function (callable): A function that accepts two arguments and returns nothing.\n    \"\"\"\n    def __init__(self, function):\n        self.accept = function\n\n\n\"\"\"\nRepresents a function that accepts two arguments and produces a result. This is the two-arity specialization of Function. \n\"\"\"\nclass BiFunction(java.util.function.BiFunction):\n\n    \"\"\"\n    Initializes a new BiFunction.\n\n    Arguments:\n        function (callable): A function that accepts two arguments and returns a value.\n    \"\"\"\n    def __init__(self, function):\n        self.apply = function\n\n\n\"\"\"\nRepresents a predicate (boolean-valued function) of two arguments. This is the two-arity specialization of Predicate. \n\"\"\"\nclass BiPredicate(java.util.function.BiPredicate):\n\n    \"\"\"\n    Initializes a new BiPredicate.\n\n    Arguments:\n        function (callable): A function that accepts two arguments and returns either True or False.\n    \"\"\"\n    def __init__(self, function):\n        self.test = function\n\n\n\"\"\"\nRepresents an operation that accepts a single input argument and returns no result. Unlike most other functional interfaces, Consumer is expected to operate via side-effects.\n\"\"\"\nclass Consumer(java.util.function.Consumer):\n\n    \"\"\"\n    Initializes a new Consumer.\n\n    Arguments:\n        function (callable): A function that accepts one argument and returns nothing.\n    \"\"\"\n    def __init__(self, function):\n        self.accept = function\n\n\n\"\"\"\nRepresents a function that accepts one argument and produces a result.\n\"\"\"\nclass Function(java.util.function.Function):\n\n    \"\"\"\n    Initializes a new Function.\n\n    Arguments:\n        function (callable): A function that accepts one argument and returns a value.\n    \"\"\"\n    def __init__(self, function):\n        self.apply = function\n\n\n\"\"\"\nRepresents a predicate (boolean-valued function) of one argument.\n\"\"\"\nclass Predicate(java.util.function.Predicate):\n\n    \"\"\"\n    Initializes a new Predicate.\n\n    Arguments:\n        function (callable): A function that accepts one argument and returns either True or False.\n    \"\"\"\n    def __init__(self, function):\n        self.test = function\n\n\n\"\"\"\nRepresents a supplier of results.\n\nThere is no requirement that a new or distinct result be returned each time the supplier is invoked.\n\"\"\"\nclass Supplier(java.util.function.Supplier):\n\n    \"\"\"\n    Initializes a new Supplier.\n\n    Arguments:\n        function (callable): A function that accepts no arguments and returns a value.\n    \"\"\"\n    def __init__(self, function):\n        self.get = function\n</code></pre>"},{"location":"scripts/functionmodule/#usage-example","title":"Usage Example","text":"<p>The following code utlizes NBT-API to set a custom NBT string to an item using a command, and then fetches the custom NBT string when the player interacts with the item in their hand.</p> <pre><code>import pyspigot as ps\nfrom function import Function # (1)!\nfrom de.tr7zw.nbtapi import NBT\nfrom org.bukkit.event.player import PlayerInteractEvent\n\ndef interact_event(event):\n    item = event.getItem()\n    if item is not None:\n        def nbt_get(nbt): # (2)!\n            return nbt.getString(\"Test_String\")\n        nbt_get_function = Function(nbt_get) # (3)!\n\n        nbt_data = NBT.get(item, nbt_get_function) # (4)!\n        print(nbt_data)\n\nps.listener_manager().registerListener(interact_event, PlayerInteractEvent)\n\ndef command(sender, label, args):\n    item = sender.getItemInHand()\n\n    to_set = 'This is a test string'\n    def set_function(nbt): # (5)!\n        nbt.setString(\"Test_String\", to_set)\n    set_function = Function(set_function) # (6)!\n\n    NBT.modify(item, set_function) # (7)!\n\nps.command_manager().registerCommand(command, 'additemnbt')\n</code></pre> <ol> <li> <p>Here, we make use of the functional interface <code>Function</code>. Most of NBT-API uses this functional interface.</p> </li> <li> <p>Here, we define a function that is essentially passed to NBT-API. NBT-API then calls this function, passing the NBT data for the corresponding item as an argument. Then, we fetch our desired NBT data inside the function and return it from the function.</p> </li> <li> <p>Here, we initialize a new <code>Function</code>, passing our previously defined <code>nbt_get</code> function as an argument.</p> </li> <li> <p>Here, we call the NBT-API, passing the item we want to get data from as well as the <code>Function</code> instance we created earlier. We then assign the returned value (the data we fetched).</p> </li> <li> <p>In a similar way as before, we define another function that is essentially passed to NBT-API. NBT-API calls this function, passing the NBT data for the corresponding item. Then, we set the NBT data this time inside of the function. We don't return anything, since we are setting data, not getting.</p> </li> <li> <p>Here, we initialize another new <code>Function</code>, passing our previously defined <code>set_function</code> function as an argument.</p> </li> <li> <p>Finally, we call the NBT-API to modify the NBT data of the item, passing the item whose NBT data we want to set as well as the <code>Function</code> instance created earlier. The <code>NBT.modify</code> function doesn't return anything since it modifies values.</p> </li> </ol> <p>This is a relatively simple example. If you are having difficulties with more complex code, feel free to ask for help on the PySpigot Discord.</p>"},{"location":"scripts/globalvariables/","title":"Global Variables","text":"<p>PySpigot contains a global variable system that is available to scripts at runtime. On the Java side, this system relies on a <code>HashMap</code>, which is a data structure that stores data in key:value pairs, much like a dict in Python. The intention of this system is to allow for shared variables across scripts. This feature might be useful if you are writing a system of scripts that rely on information from other scripts in order to function correctly.</p> <p>Changes to variables inserted into this global set are automatically visible to all scripts. There is no need to re-insert a variable into the global set of variables if its value changes.</p>"},{"location":"scripts/globalvariables/#accessing-the-global-variables-system","title":"Accessing the Global Variables System","text":"<p>PySpigot's global variables system is accessed just like any of PySpigot's managers. There are two ways to access it:</p>"},{"location":"scripts/globalvariables/#via-the-pyspgigot-helper-module","title":"Via the pyspgigot helper module","text":"<pre><code>import pyspigot as ps\n\nglobal_vars = ps.global_variables()\n\nglobal_vars.&lt;function&gt;\n</code></pre> <p>The pyspigot helper module also defines a couple common aliases for convenience. Both <code>ps.global_vars</code> and <code>ps.gv</code> work. For example:</p> <pre><code>import pyspigot as ps\n\nps.global_vars.&lt;function&gt;\nps.gv.&lt;function&gt;\n</code></pre>"},{"location":"scripts/globalvariables/#via-a-direct-import","title":"Via a direct import","text":"<pre><code>from dev.magicmq.pyspigot.manager.script import GlobalVariables as global_vars\n\nglobal_vars.get().&lt;function&gt;\n</code></pre> Warning <p>If you access the global variables system via a direct import, you must call <code>get()</code>!</p>"},{"location":"scripts/globalvariables/#usage","title":"Usage","text":"<p>Basic usage of the global variables system would involve calling the <code>set</code>, <code>get</code>, and <code>remove</code> functions. See below for more detailed descriptions of these functions. Here is a short example:</p> Script AScript B <pre><code>import pyspigot as ps\n\nglobal_vars = ps.global_variables()# (1)!\n\ntest = 'Global variable'\n\nglobal_vars.set('test', test)# (2)!\n</code></pre> <ol> <li>On this line, the global variables system is fetched from the <code>pyspigot</code> helper module.</li> <li>On this line, a new value is set into the global variables system with the key \"test\", and the value of the variable <code>test</code> (\"Global variable\")</li> </ol> <pre><code>import pyspigot as ps\n\nglobal_vars = ps.global_variables()# (1)!\n\ntest = global_vars.get('test')# (2)!\n\nprint(test)\n\nglobal_vars.remove('test')# (3)!\n</code></pre> <ol> <li>On this line, the global variables system is fetched from the <code>pyspigot</code> helper module.</li> <li>On this line, the value assigned to the key \"test\" is obtained. This was set earlier in Script A.</li> <li>Once finished obtaining the variable, it is removed with the <code>remove</code> function, passing the key that should be removed. Removing the variable once finished using it is crucial to prevent memory leaks. See the Avoiding Memory Leaks section below for more information.</li> </ol> <p>In the above code, we set the variable <code>test</code> in the global variables system in script A. Then, we retrieve and print the value of <code>test</code> from script B, and remove the variable after we retrieve it.</p> Warning <p>Keys/Names are unique. If a new value is inserted into the set of global values with the same key as an existing value, then the old value will be overridden and inevitably lost.</p> Notice <p>There is no need to set the variable to the global variables system again if its value changes. Once a global variable is set in the global variables system, its value is updated automatically.</p>"},{"location":"scripts/globalvariables/#advanced-usage","title":"Advanced Usage","text":"<p>The global variables system contains a function called <code>getHashMap()</code>, which returns the underlying Java HashMap where variables are stored. You can use this function to get the underlying HashMap in order to access more advanced functions. For a complete list of available functions within the Java HashMap class, see the JavaDocs for HashMap.</p>"},{"location":"scripts/globalvariables/#avoiding-memory-leaks","title":"Avoiding Memory Leaks","text":"<p>The global variables system is not smart. It will keep variables stored indefinitely, unless if they are overritten or intentionally deleted. The system will not remove variables unless it is explicitly told to do so. Consider the following example:</p> <ul> <li>Script A sets a variable to the global variables system for script B to use.</li> <li>Script B retrieves the variable and uses it.</li> <li>Script B is stopped or otherwise finishes using the variable.</li> <li>Script A continues going about its business.</li> </ul> <p>In the above example, the global variable still exists in the global variables system, because neither script A nor script B cleared the variable from the system. In this case, the variable is leaky: it still exists and can be read, but it's not being used anymore. In programming, this is called a memory leak, and it is frowned upon because it leads to unnecessary use of memory. It's also preventable.</p> <p>Returning to the above example: because script B is the script using the data, script A has no way of knowing when script B has seen that data. Therefore, it is script B's responsibility to remove the variable from the global variables system when it is finished retrieving it. You can see this is done in the above code once the <code>test</code> variable is printed.</p> <p>In general, when you're working with the global variables system, you should ensure that somewhere in your code, old variables are removed when they're no longer neeeded.</p>"},{"location":"scripts/globalvariables/#available-functions","title":"Available Functions","text":"<p>The following is a list of available functions in the global variables system:</p>"},{"location":"scripts/globalvariables/#setkey-value","title":"<code>set(key, value)</code>","text":"<p>Insert a new value into the global set of variables with the given key (name). This function will always override an existing variable with the same key.</p> <ul> <li>Parameters:<ul> <li>key: The key of the global variable to set</li> <li>value: The value of the variable to set</li> </ul> </li> <li>Returns: The value that was previously set with the given key, or <code>None</code> if there was none</li> </ul> Warning <p>The <code>set(key, value)</code> function will override an existing value with the same key!</p>"},{"location":"scripts/globalvariables/#setkey-value-override","title":"<code>set(key, value, override)</code>","text":"<p>Insert a new value into the global set of variables with the given key (name), with the option to override an existing value.</p> <ul> <li>Parameters:<ul> <li>key: The key of the global variable to set</li> <li>value: The value of the variable to set</li> <li>override: Pass <code>True</code> if an existing variable with the given key should be overridden. Pass <code>False</code> if an existing variable with the same key should not be overridden</li> </ul> </li> <li>Returns: The value that was previously set with the given key, or <code>None</code> if there was none</li> </ul>"},{"location":"scripts/globalvariables/#removekey","title":"<code>remove(key)</code>","text":"<p>Remove a global variable with the given key (name).</p> <ul> <li>Parameters:<ul> <li>key: The key of the global variable to remove</li> </ul> </li> <li>Returns: The value of the variable that was removed, or <code>None</code> if there was no global variable that was removed</li> </ul>"},{"location":"scripts/globalvariables/#getkey","title":"<code>get(key)</code>","text":"<p>Get a global variable with the given key (name).</p> <ul> <li>Parameters:<ul> <li>key: The key of the global variable to get</li> </ul> </li> <li>Returns: The variable with the given key, or <code>None</code> if no values were found under the given key</li> </ul>"},{"location":"scripts/globalvariables/#getkeys","title":"<code>getKeys()</code>","text":"<p>Get a list of all global variable keys (names) that are currently set.</p> <ul> <li>Returns: An immutable<sup>1</sup> set of the keys of all global variables currently stored. Will return an empty set if there are no global variables that are set</li> </ul>"},{"location":"scripts/globalvariables/#getvalues","title":"<code>getValues()</code>","text":"<p>Get a list of all global variable values that are currently set.</p> <ul> <li>Returns: An immutable<sup>1</sup> set of the values of all currently stored global variables. Will return an empty set if there are no global variables</li> </ul>"},{"location":"scripts/globalvariables/#gethashmap","title":"<code>getHashMap()</code>","text":"<p>Get the underlying Java HashMap data structure that stores all global variables.</p> <ul> <li>Returns: The underlying HashMap, which is mutable<sup>2</sup></li> </ul>"},{"location":"scripts/globalvariables/#containskey","title":"<code>contains(key)</code>","text":"<p>Check if a global variable is currently stored with the given key (name).</p> <ul> <li>Returns: <code>True</code> if there is a global variable with the given key, <code>False</code> if there is not</li> </ul>"},{"location":"scripts/globalvariables/#containsvaluevalue","title":"<code>containsValue(value)</code>","text":"<p>Check if a global variable currently exists with the given value.</p> <ul> <li>Returns: <code>True</code> if there is a global variable with the given value, <code>False</code> if there is not</li> </ul>"},{"location":"scripts/globalvariables/#purge","title":"<code>purge()</code>","text":"<p>Clear all variables from the global variables system. Acts as a hard \"reset\" to the system.</p>"},{"location":"scripts/globalvariables/#summary","title":"Summary","text":"<ul> <li>The global variables system allows for cross-script sharing of variables.</li> <li>The global variables system is accessed just like any of PySpigot's managers.</li> <li>Basic usage involves the <code>set</code>, <code>get</code>, and <code>remove</code> functions.</li> <li>The keys/names of global variables are unique. If a new variable is inserted with the same key as an existing variable, the old value will be lost.</li> <li>The values of variables stored in the global variables system are updated automatically, and changes are automatically visible to scripts accessing them without needing to call the <code>set</code> function over again.</li> <li>Global variables should be removed when scripts finish using them in order to avoid memory leaks.</li> <li>The global variables system uses a Java HashMap, and this underlying HashMap can be accessed with the <code>getHashMap</code> function.</li> </ul> <ol> <li> <p>Immutable in this context means that any changes made to the set/list that is returned are not reflected in the global variables system. In other words, the set/list is not backed by the global variables HashMap.\u00a0\u21a9\u21a9</p> </li> <li> <p>Mutable in this context means that any changes made to the HashMap that is returned will be reflected in the global variables system.\u00a0\u21a9</p> </li> </ol>"},{"location":"scripts/helpermodule/","title":"The PySpigot Helper Module","text":"Once Upon a Time... <p>Prior to PySpigot version 0.8.0, the <code>pyspigot.py</code> helper module was automatically copied into the <code>python-libs</code> folder. Since version 0.8.0, this no longer occurs, as the module is bundled into the JAR in such a way that makes it directly accessible (no copying required!).</p> <p>If you still have the <code>pyspigot.py</code> helper module in your <code>python-libs</code> folder, it is safe to delete :)</p> <p>PySpigot includes a helper module, <code>pyspigot.py</code>. This module is bundled into the PySpigot JAR file. This module is designed to make it easier to access PySpigot's managers from within your script. The code for this module is included below for your reference, along with some documentation for clarity.</p>"},{"location":"scripts/helpermodule/#code","title":"Code","text":"<pre><code>\"\"\"\nA helper module for more easy access to PySpigot's managers.\n\"\"\"\nfrom dev.magicmq.pyspigot.bukkit import PySpigot\nfrom dev.magicmq.pyspigot.manager.script import ScriptManager\nfrom dev.magicmq.pyspigot.manager.script import GlobalVariables\nfrom dev.magicmq.pyspigot.manager.listener import ListenerManager\nfrom dev.magicmq.pyspigot.manager.command import CommandManager\nfrom dev.magicmq.pyspigot.manager.task import TaskManager\nfrom dev.magicmq.pyspigot.manager.config import ConfigManager\nfrom dev.magicmq.pyspigot.manager.database import DatabaseManager\nfrom dev.magicmq.pyspigot.manager.redis import RedisManager\n\n\ndef script_manager():\n    \"\"\"\n    Get the script manager for loading, unloading, and reloading\n    scripts.\n    \"\"\"\n    return ScriptManager.get()\n\n\ndef global_variables():\n    \"\"\"\n    Get the global variables manager for setting and getting global\n    variables.\n    \"\"\"\n    return GlobalVariables.get()\n\n\ndef listener_manager():\n    \"\"\"\n    Get the listener manager for registering and unregistering\n    event listeners.\n    \"\"\"\n    return ListenerManager.get()\n\n\ndef command_manager():\n    \"\"\"\n    Get the command manager for registering and unregistering\n    commands.\n    \"\"\"\n    return CommandManager.get()\n\n\ndef task_manager():\n    \"\"\"\n    Get the task manager for scheduling and unscheduling tasks\n    (synchronous and asynchronous).\n    \"\"\"\n    return TaskManager.get()\n\n\ndef config_manager():\n    \"\"\"\n    Get the config manager for writing to and reading from config\n    files.\n    \"\"\"\n    return ConfigManager.get()\n\n\ndef database_manager():\n    \"\"\"\n    Get the database manager for connecting to and interacting\n    with databases.\n    \"\"\"\n    return DatabaseManager.get()\n\n\ndef redis_manager():\n    \"\"\"\n    Get the redis manager for connecting to and interacting with\n    redis servers.\n    \"\"\"\n    return RedisManager.get()\n\n\ndef protocol_manager():\n    \"\"\"\n    Get the protocol manager for working with ProtocolLib\n    (registering/unregistering packet listeners, sending packets, etc.).\n\n    Note: this function will return None if ProtocolLib is not available\n    on the server.\n    \"\"\"\n    if PySpigot.get().isProtocolLibAvailable():\n        from dev.magicmq.pyspigot.bukkit.manager.protocol import ProtocolManager\n        return ProtocolManager.get()\n    else: return None\n\n\ndef placeholder_manager():\n    \"\"\"\n    Get the placeholder manager for registering/unregistering\n    PlaceholderAPI placeholders.\n\n    Note: this function will return None if PlaceholderAPI is not available\n    on the server.\n    \"\"\"\n    if PySpigot.get().isPlaceholderApiAvailable():\n        from dev.magicmq.pyspigot.bukkit.manager.placeholder import PlaceholderManager\n        return PlaceholderManager.get()\n    else: return None\n\n\n# Convenience variables for ease of access\n\nscript = script_manager()\nscripts = script_manager()\nsm = script_manager()\n\n\nglobal_vars = global_variables()\ngv = global_variables()\n\n\nlistener = listener_manager()\nlisteners = listener_manager()\nlm = listener_manager()\nevent = listener_manager()\nevents = listener_manager()\nem = listener_manager()\n\n\ncommand = command_manager()\ncommands = command_manager()\ncm = command_manager()\n\n\nscheduler = task_manager()\nscm = task_manager()\ntasks = task_manager()\ntm = task_manager()\n\n\nconfig = config_manager()\nconfigs = config_manager()\ncom = config_manager()\n\n\ndatabase = database_manager()\n\n\nredis = redis_manager()\n\n\nprotocol = protocol_manager()\nprotocol_lib = protocol_manager()\nprotocols = protocol_manager()\npm = protocol_manager()\n\n\nplaceholder = placeholder_manager()\nplaceholder_api = placeholder_manager()\nplaceholders = placeholder_manager()\nplm = placeholder_manager()\n</code></pre>"},{"location":"scripts/scriptoptions/","title":"Script Options","text":"<p>In PySpigot's main plugin folder, you'll find a file titled <code>script_options.yml</code>. This file enables you to specify various script-specific options, all of which are covered here.</p> Tip <p>Defining script options for each script is optional. See the Defaults section for more information.</p>"},{"location":"scripts/scriptoptions/#basic-format","title":"Basic Format","text":"<p>If you would like to specify options for a script, do it like so:</p> <pre><code>test.py: # (1)!\n  enabled: true\n  file-logging-enabled: true\n</code></pre> <ol> <li>All options defined under this section apply to the script <code>test.py</code> only.</li> </ol> <p>Each section in the <code>script_options.yml</code> file should be the name of a script. The name must exactly match the script's name, (including <code>.py</code>), or the options won't be parsed for that script.</p> <p>All options within the section apply to the script by which the section is named. In the above example, the options <code>enabled</code> and <code>file-logging-enabled</code> apply to the script <code>test.py</code>.</p>"},{"location":"scripts/scriptoptions/#defining-options-for-multiple-scripts","title":"Defining Options for Multiple Scripts","text":"<p>If you would like to define options for multiple scripts, do it like so:</p> <pre><code>test.py: # (1)!\n  enabled: true\n  file-logging-enabled: true\ntest2.py: # (2)!\n  enabled: true\n  load-priority: 10\n</code></pre> <ol> <li>The options defined under this section apply to the script <code>test.py</code>.</li> <li>The options defined under this section apply to the script <code>test2.py</code>.</li> </ol> <p>As you can see, in the above example, we define a new section titled <code>test2.py</code>, and all options within this section will apply to the <code>test2.py</code> script. All options within the <code>test.py</code> script still apply only to the script <code>test.py</code>.</p>"},{"location":"scripts/scriptoptions/#defaults","title":"Defaults","text":"<p>Specifying script options for each script is not a requirement. PySpigot relies on fallbacks as well as default values for script options in the event that they aren't defined in the <code>script_options.yml</code> file for the script that is being loaded. The following diagram illustrates the process by which PySpigot searches for script options when a script loads.</p> <pre><code>graph LR\n  A[Script loads] --&gt; B{Option present in script_options.yml?};\n  B --&gt;|Yes| C[Use option from script_options.yml]\n  B --&gt;|No| D{Default option present in config.yml?}\n  D --&gt;|Yes| E[Use default option defined in config.yml]\n  D --&gt;|No| F[Use internal default option]</code></pre> <p>PySpigot first checks if an option is present in the <code>script_options.yml</code> file. If the option isn't defined here, then it will fall back to whatever default value is defined in the <code>config.yml</code> under <code>script-option-defaults</code>. If a default option isn't specified here, then it will fall back to an internally defined default value.</p> <p>PySpigot performs this process for each script option individually.</p>"},{"location":"scripts/scriptoptions/#options","title":"Options","text":""},{"location":"scripts/scriptoptions/#enabled","title":"<code>enabled</code>","text":"<p>Specify whether a script is enabled or disabled. To disable a script, set this value to <code>false</code>.</p> <pre><code>test.py:\n  enabled: true\n</code></pre> <p>Default: <code>true</code></p>"},{"location":"scripts/scriptoptions/#load-priority","title":"<code>load-priority</code>","text":"<p>Specify an integer load priority for the script. Scripts and projects are loaded in order from highest to lowest load priority. In other words, scripts/projects that have a higher load priority are loaded earlier, and scripts/projects with a lower load priority are loaded later. If multiple scripts and projects have the same load priority, they are loaded in alphabetical order.</p> <pre><code>test.py:\n  load-priority: 1\n</code></pre> <p>Default: 1</p>"},{"location":"scripts/scriptoptions/#plugin-depend","title":"<code>plugin-depend</code>","text":"<p>Specify a list of plugins that this script requires to load. The script will not load if any of the plugin dependencies are not loaded and running on the server. Additionally, when a plugin is unloaded/disabled, any scripts that depend on that plugin as specified under this option are automatically unloaded (if the <code>script-unload-on-plugin-disable</code> option in the <code>config.yml</code> is set to <code>true</code>).</p> <pre><code>test.py:\n  plugin-depend: ['Citizens', 'Vault']\n</code></pre> Notice <p>If you are working with ProtocolLib or PlaceholderAPI in your script, you do not need to specify either of them here. PySpigot has built-in support for these two plugins, and the dependency management is handled internally.</p> <p>Default: None (empty list)</p>"},{"location":"scripts/scriptoptions/#file-logging-enabled","title":"<code>file-logging-enabled</code>","text":"<p>Specify if script file logging should be enabled for the script. If this option is <code>true</code>, a script log file will be generated, and any error messages (and print messages sent to the script's logger) will be logged to this file. If this option is <code>false</code>, no messages will be logged to a log file, but messages will still be printed to the server console.</p> <pre><code>test.py:\n  file-logging-enabled: true\n</code></pre> <p>Default: <code>true</code></p>"},{"location":"scripts/scriptoptions/#min-logging-level","title":"<code>min-logging-level</code>","text":"<p>Specify the minimum logging level that should be logged to the script's log file and the console. Options can be found on the JavaDocs.</p> <pre><code>test.py:\n  min-log-level: 'INFO'\n</code></pre> <p>Default: <code>INFO</code></p>"},{"location":"scripts/scriptoptions/#permissions","title":"<code>permissions</code>","text":"<p>Specify a list of permissions that the script uses. This is useful for scripts that want to restrict access to certain features. This section is defined in the exact same way that permissions are defined in the <code>plugin.yml</code> file for a Bukkit plugin. See usage code example below for how to define permissions, defaults, and child permissions.</p> <pre><code>test.py:\n  permissions:\n    permission.node.*:\n      description: 'This is a permission node'\n      default: op\n      children:\n        permission.node.child: true\n    permission.node.child:\n      description: 'This is a child permission node'\n      default: true\n    another.permission.node:\n      description: 'This is another permission node'\n      default: not op\n</code></pre> <ul> <li><code>description</code> is a description of the permission node, and this is what will be displayed in the permissions list. The default value is the name of the permission node.</li> <li><code>default</code> is the default value of the permission node, or, in other words, who should have the permission node by default. There are four possible values for <code>default</code>: </li> <li><code>op</code>: Only server operators will have the permission node by default.</li> <li><code>not op</code>: Players who are not operators will have the permission node by default.</li> <li><code>true</code>: All players will have the permission (I.E. it is a default permission).</li> <li><code>false</code>: No players will have the permission (I.E. it is not a default permission). The default value is the value of <code>default_permission</code> (outlined below).</li> <li><code>children</code> is a list of child permissions that should inherit from the parent permission. Each permission node may have children. When set to <code>true</code>, the child will inherit the parent permission.</li> </ul> <p>Default: None (no permissions defined)</p>"},{"location":"scripts/scriptoptions/#permission-default","title":"<code>permission-default</code>","text":"<p>Specify a default value that permissions should have, if they do not have a <code>default</code> value defined.</p> <pre><code>test.py:\n  permission-default: true\n</code></pre> <p>The allowed values for <code>permission-default</code> are <code>op</code>, <code>not op</code>, <code>true</code>, and <code>false</code>:</p> <ul> <li><code>op</code>: Only server operators will have the permission node by default.</li> <li><code>not op</code>: Players who are not operators will have the permission node by default.</li> <li><code>true</code>: All players will have the permission (I.E. it is a default permission).</li> <li><code>false</code>: No players will have the permission (I.E. it is not a default permission). </li> </ul> <p>Default: <code>op</code></p>"},{"location":"scripts/writingscripts/","title":"Writing Scripts","text":"<p>This tutorial provides an overview of PySpigot only, and does not cover in detail the Bukkit/Spigot API or writing Python code. Any questions concerning Python syntax or writing Python code in general should be redirected to the appropriate forum, as this tutorial will not provide an intoroduction to writing basic Python code. </p> <p>There are a few basic things to keep in mind when writing PySpigot scripts:</p> <ul> <li>As of version 0.9.1, PySpigot requires Java 21 or above.</li> <li>PySpigot officially supports Spigot and Paper on Minecraft versions 1.16 and newer.</li> <li>Under the hood, PySpigot utilizes Jython, a Java implementation of Python. Currently, Jython implements Python 2 only, so Python 2 syntax should be used when writing PySpigot scripts.</li> <li>Scripts must be written in Python syntax and script files should in <code>.py</code>. Files that do not end in .py will not be loaded.</li> <li>Scripts are placed in the <code>scripts</code> folder under the PySpigot plugin folder. PySpigot allows for creation of subfolders within the scripts folder for organizational purposes, but script names must be unique across all subfolders and projects.</li> <li>Projects are placed in the <code>projects</code> folder under the PySpigot plugin folder. </li> <li>Avoid using the variable names <code>global</code> and <code>logger</code>. These variable names are assigned automatically at runtime. More information on these below.</li> <li>Scripts and projects are functionally isolated from one another. With the exception of the <code>global</code> variable (see the Global Variables section below), nothing is shared across scripts or projects.</li> <li>To make use of any of the managers that PySpigot provides (such as registering listeners, tasks, etc.), they must be imported into your script. See the managers page for more details.</li> <li>If you are utilizing the API of any plugin other than ProtocolLib or PlaceholderAPI, make sure you specify the plugin as a dependency in the <code>script_options.yml</code> file. See the Script Options page for more info.</li> </ul> Notice <p>This page covers core fundamentals for writing both single-file scripts and multi-file projects. However, writing multi-file projects carries some key differences to be aware of. For more information, see the writing projects page.</p>"},{"location":"scripts/writingscripts/#a-note-about-jython","title":"A Note About Jython","text":"<p>Under the hood, PySpigot utilizes Jython, a Java implementation of Python. The PySpigot jar file is quite large in comparison to other Bukkit plugins because Jython (as well as its dependencies) are bundled into PySpigot.</p> <p>Jython is written such that scripts are compiled and interpreted entirely in Java. This means that scripts have native access to the entire Java class path at runtime, making it very easy to work with the Spigot API and other aspects of the server. Consider the following example:</p> <pre><code>from org.bukkit import Bukkit\nfrom org.bukkit import Location\n\nteleport_location = Location(Bukkit.getWorld('world'), 0, 64, 0)\n\nonline_players = Bukkit.getOnlinePlayers()\n\nfor player in online_players:\n    player.teleport(teleport_location)\n</code></pre> <p>As you can see from the above code block, working with Java classes/objects is intuitive. Should you have any trouble interfacing with Java, Jython has fairly well-written documentation you can check out here.</p> <p>By default, Jython internals are initialized on server startup (when PySpigot is loaded). This can result in a momentary hang during startup when PySpigot is loading. This also results in some memory overhead, even if no scripts are loaded. To disable this feature, and instead delay initialization of Jython until script loading, set <code>init-on-startup</code> to <code>false</code> in the <code>jython-options</code> section of the PySpigot config file.</p> <p>Currently, the latest version of Jython implements Python 2. Thus, for now, PySpigot scripts are written in Python 2. While some may see this as a drawback, Python 2 is usually sufficient for the vast majority of use cases of PySpigot, and I have not yet found any case where a Python 3 feature was required for script functionality. The developers of Jython intend on implementing Python 3 in a future release of Jython, but the expected timeframe of this update is unclear. Work is ongoing on the Jython GitHub repository.</p> <p>For more information about Jython, visit jython.org.</p>"},{"location":"scripts/writingscripts/#standard-python-libraries","title":"Standard Python Libraries","text":"<p>Jython does not support many of the built-in Python modules (i.e. those that are written in C for Python). These would have to be ported to Java or implemented with a JNI bridge. Some built-in modules have been ported to Jython, most notably <code>cStringIO</code>, <code>cPickle</code>, <code>struct</code>, and <code>binascii</code>. Jython's documentation states it is unlikely JNI modules will ever be included in the Jython proper.</p> <p>Jython now supports a large marjority of the standard Python library. However, Jython's documentation has been slow in keeping up with these additions, so if Jython's documentation does not reference a library, it may still be supported.</p> <p>If you want to use a standard Python module in your script, try importing it. If that works, then you're probably all set. You can also call <code>dir()</code> on the modules to check the list of functions it implements.</p>"},{"location":"scripts/writingscripts/#basic-script-information","title":"Basic Script Information","text":"<p>All PySpigot scripts are designed to be self-contained, single files. This means that each script will, at most, consist of one file only. Additionally, scripts are isolated from one another, meaning they do not share variables, functions, or scope. Scripts are capable of interacting with one another in various ways (more detail on this below), but think of each .py file in the <code>scipts</code> folder as an individual entity, executed in its own environment.</p> <p>PySpigot scripts are placed in the <code>scripts</code> folder, which can be found in PySpigot's main plugin folder. Creation of subfolders within the <code>scripts</code> folder for organizational purposes is supported. PySpigot will attempt to load any file in the <code>scripts</code> folder (including in subfolders) that ends in the <code>.py</code> extension. Any files in the <code>scripts</code> folder that do not end in <code>.py</code> will not be loaded.</p> Warning <p>Script names must be unique across other script names and project names, as their names are used to identify them at runtime. This caveat also applies if you are using subfolders within the <code>scripts</code> folder. For example, <code>scripts/folder1/test.py</code> and <code>scripts/folder2/test.py</code> will conflict, but <code>scripts/folder1/test.py</code> and <code>scripts/folder2/test2.py</code> will not.</p>"},{"location":"scripts/writingscripts/#script-options","title":"Script Options","text":"<p>There are a variety of options that can be set for each script, including whether or not it is enabled, load priority, and logging options. These are set within the <code>script_options.yml</code> file in PySpigot's main plugin folder. For more information on script options, see the Script Options page.</p> Notice <p>Defining script options for each script is optional; scripts will function normally without explicitly-defined options.</p>"},{"location":"scripts/writingscripts/#script-permissions","title":"Script Permissions","text":"<p>PySpigot allows scripts to define a list of permissions that it uses. This is useful if scripts want to restrict access to certain features. Script permissions are initialized and loaded just prior to parsing and executing the script's code, and are removed just after a script is stopped.</p> <p>Script permissions are defined in the <code>script_options.yml</code> file. For more information on how to define permissions, see the documentation for script options.</p>"},{"location":"scripts/writingscripts/#script-loading","title":"Script Loading","text":"<p>PySpigot loads and runs all scripts in the scripts folder (including scripts within subfolders) automatically on plugin load or server start. Script load order is determined by load priority, as defined in the <code>script_options.yml</code> file. Scripts that don't specify a load priority will inherit the default load priority specified in the <code>script-option-defaults</code> section of the <code>config.yml</code>. Scripts that have the same load priority are loaded in alphabetical order.</p> <p>Scripts can also be manually loaded using <code>/pyspigot load &lt;scriptname&gt;</code> if you want to load/enable a script after server start/plugin load. If you make changes to a script during runtime, you must reload it for changes to take effect. Reload scripts with <code>/pyspigot reload &lt;scriptname&gt;</code>.</p> <p>There is one config option related to loading scripts:</p> <ul> <li><code>script-load-delay</code>: This is the delay, in ticks, that PySpigot will wait after server loading is completed to load scripts and projects. There are 20 server ticks in one real-world second. For example, if the value is 20, then PySpigot will wait 20 ticks (or 1 second) after the server finishes loading to load scripts and projects.</li> </ul> Notice <p>Scripts and projects are interlaced when loading. In other words, they are loaded together. This means that the load priorities of scripts and projects are compared simultaneously, and a project with a higher load priority would load earlier than a script with a lower load priority, and vice versa.</p>"},{"location":"scripts/writingscripts/#script-unloading","title":"Script Unloading","text":"<p>Scripts can be manually unloaded using <code>/pyspigot unload &lt;scriptname&gt;</code>. Running <code>/pyspigot reload</code> will also unload a script first before loading it again (if it was running beforehand).</p>"},{"location":"scripts/writingscripts/#unloading-a-script-from-within-itself","title":"Unloading A Script from Within Itself","text":"<p>Unloading a script from within itself is done in the same way as it is in regular Python, via usage of the <code>sys.exit</code> function:</p> <pre><code>import sys\n\nsys.exit(0)\n</code></pre> <p>Internally, calling <code>sys.exit</code> raises a <code>SystemExit</code> exception. PySpigot catches this exception and performs its standard unloading tasks to unload the script that raised the exception.</p> <p>If you want to unload your script with a signal that an error occured, pass <code>1</code> to <code>sys.exit</code>. Doing so will prevent the script's <code>stop</code> function from being called on unload.</p> Warning <p>Do not use the script manager to unload a script from within itself! This will lead to unexpected bugs/issues.</p>"},{"location":"scripts/writingscripts/#start-and-stop-functions","title":"Start and Stop Functions","text":"<p>There are two special functions you may include in your PySpigot scripts: <code>start</code> and <code>stop</code>.</p> <p>The <code>start</code> function is called automatically by PySpigot when your script loads. Likewise, the <code>stop</code> function is called automatically by PySpigot when your script unloads. If your script is unloaded as a result of an error, the <code>stop</code> function is not called. This error condition also includes unloading a script via <code>sys.exit</code> with an exit code of <code>1</code>.</p> <p>The <code>start</code> and <code>stop</code> functions can accept either zero or one parameter:</p> <ul> <li>If you define one parameter, PySpigot will pass the Script Object to the function. This object is the representation of the loaded script at runtime. This allows you to obtain information about the script, as well as other key functions, including logging, the script file, and more within the <code>start</code> and/or <code>stop</code> function.</li> <li>If you define zero parameters, PySpigot will not pass any arguments to the function.</li> </ul> Notice <p>The <code>start</code> and <code>stop</code> functions are optional. You do not need to define them in your script if they are not needed.</p>"},{"location":"scripts/writingscripts/#the-pyspigotpy-helper-module","title":"The <code>pyspigot.py</code> Helper Module","text":"<p>PySpigot ships with a helper module called <code>pyspigot.py</code> that contains various useful functions to access PySpigot's manager classes. This module is accessible via a simple import:</p> <pre><code>import pyspigot as ps\n\n...\n</code></pre> <p>For more information, see the PySpigot Helper Module page.</p>"},{"location":"scripts/writingscripts/#global-variables","title":"Global Variables","text":"<p>PySpigot includes a global variable system that allows variables to be shared across different scripts. On the Java end, this system is backed by a <code>HashMap</code>, which stores data in key:value pairs, much like a dict in Python. The intention of this system is to act as a global set of variables in the event that multiple scripts need to access the same variable. This is a nifty feature if you would like to share variables/values across multiple different scripts.</p> <p>See the Global Variables page for detailed information on how to use the global variables system.</p>"},{"location":"scripts/writingscripts/#script-errors-and-exceptions","title":"Script Errors and Exceptions","text":"<p>Scripts can generate errors/exceptions. PySpigot handles all exceptions generated by scripts, in order to: 1) log the exception to console and the script's logger, and 2) to terminate the script's execution if the exception was fatal.</p> <p>If a script happens to generate an unhandled error/exception when it is loaded, the script will be automatically unloaded to prevent further issues. If an unhandled error/exception occurs somewhere else at a later point in time, such as during execution of an event listener or command executor, the script will remain loaded, but subsequent code within the function will not be executed (unless if, of course, the exception is surrounded with a <code>try</code>/<code>except</code> block).</p> <p>In any case, errors/exceptions will be logged to the console and to the respective script's log file (if the script has file logging enabled per its script options).</p> Notice <p>Because PySpigot is an active project in youth stages of development, you may encounter exceptions that are caused by a bug within PySpigot itself. If something goes wrong with your script, and your debuging efforts have been futile, please submit an issue on Github or join the Discord to ask for help.</p> <p>There are two types of errors that a script can produce:</p>"},{"location":"scripts/writingscripts/#python-errors","title":"Python Errors","text":"<p>These exceptions occur when there is an error/exception raised from within the script's own code. Because these exceptions originate in Python code, debugging them is fairly straightforward. A traceback will be shown along with the error that was raised. Here is an example of what a Python error would look like:</p> <p></p>"},{"location":"scripts/writingscripts/#java-exceptions","title":"Java Exceptions","text":"<p>These exceptions occur when a script calls Java code and the exception occurs somewhere in the Java code that was called (but not from within the script itself). These exceptions will also generate a log entry with a Python traceback indicating the script file and line that caused the exception. Here is an example of what a Java exception would look like:</p> <p></p> <p>These look similar to Python exceptions, however, in addition to a Python traceback, there will be an accompanying Java exception and stack trace. The message that accompanies the Java exception (boxed in red in the above image) typically provides additional details about why the exception occurred. For example, the message accompanying the above exception states that the command \"test\" has already been registered (I.E. the script attempted to register the same command twice).</p> <p>PySpigot routinely throws these types of exceptions (in the form of a <code>ScriptRuntimeException</code>) for erroneous/non-permitted operations that scripts attempt to perform, such as registering two different listeners for the same event, or registering two commands with the same name. A <code>ScriptRuntimeException</code> could also be thrown if some unhandled exception occurs in PySpigot's internals, such as an exception that occurred when registering an event listener with Bukkit.</p> Note <p>Java exceptions may also have a cause, which essentially means the execption was thrown as a cause of another exception. If there is a cause, the cause would also be included in the error message (along with a message and stack trace).</p>"},{"location":"scripts/writingscripts/#handling-exceptions","title":"Handling Exceptions","text":"<p>You may use Python's <code>try:</code> and <code>except:</code> syntax in order to handle exceptions yourself. For example:</p> <pre><code>import pyspigot as ps\nfrom java.lang import RuntimeException # (1)!\n\ndef command():\n    return True\n\ntry:\n  ps.command.registerCommand(command, 'testcommand')\nexcept RuntimeException as e: # (2)!\n  print(\"The command /testcommand is already registered.\")\n</code></pre> <ol> <li>Import the appropriate Java exception for use in a <code>try</code> <code>except</code> block later.</li> <li>Except the Java <code>RuntimeException</code> in the same way that a Python error would be excepted.</li> </ol>"},{"location":"scripts/writingscripts/#script-logging","title":"Script Logging","text":"<p>Like scripts themselves, a script's logger is self-contained. Each script has its own logger, which is a subclass of java.util.logging.Logger. PySpigot creates a new logger for each running script. A script's logger is automatically assigned to its global namespace under the variable name <code>logger</code>. To access your script's logger, use the <code>logger</code> variable. For example:</p> <pre><code>import pyspigot as ps\nfrom java.util.logging import Level\n\ndef task():\n    print('Task executed')\n\ntask_id = ps.scheduler.runTaskLater(task, 500)\n\nlogger.log(Level.INFO, f'Registered a new task with the ID {task_id}') # (1)!\n</code></pre> <ol> <li>The <code>logger</code> varaible can be utilized immediately without assigning it first, since the script's logger is automatically assigned to the <code>logger</code> variable when the script is started.</li> </ol> <p>When accessing your script's logger, you can use any of the functions listed here. PySpigot adds two additional functions for convenience:</p> <ul> <li><code>logger.print(message)</code>: Useful for quickly adding debug messages to your script</li> <li><code>logger.debug(message)</code>: Under the hood, functions the same as <code>logger.print</code></li> </ul> Notice <p>As of PySpigot 0.7.0, any messages printed via Python's <code>print</code> function are automatically captured and redirected to a script's logger. This makes it much easier to discern which print statements came from which script (if you have multiple scripts running), since the script's name is attached to all print messages.</p> <p><code>[STDOUT]</code> is also attached to print messages to indicate that the message was printed to <code>STDOUT</code>.</p>"},{"location":"scripts/writingscripts/#script-log-files","title":"Script Log Files","text":"<p>As stated previously, each script has its own log file. Script log files can be found in the <code>logs</code> folder within the PySpigot plugin folder. All messages related to a script will be logged in its respective log file. If you would like to disable file logging for a script, set the <code>file-logging-enabled</code> script option to <code>false</code>.</p> <p>The script logger also logs messages with an attached level. These levels are the Java logging levels. In short, the levels represent the acuity/severity of the log message. The three most common logging levels you will see are <code>INFO</code>, <code>WARNING</code>, and <code>SEVERE</code>:</p> <ul> <li><code>INFO</code>: This level demarcates the message as an informational message.</li> <li><code>WARNING</code>: This level demarcates the log message as a potential problem, but no immediate action is required.</li> <li><code>SEVERE</code>: This level demarcates the log message as a serious failure, exception, or error, that requires prompt action.</li> </ul> <p>Each script logger has a default minimum level at which log messages are logged. By default, this value is set to <code>INFO</code>. With a minimum level set at <code>INFO</code>, messages at the <code>INFO</code> level and higher (<code>WARNING</code>, <code>SEVERE</code>) are logged, but messages lower than the <code>INFO</code> level (<code>CONFIG</code>, <code>FINE</code>, <code>FINER</code>, <code>FINEST</code>) are not logged.</p> <p>You may change the minimum logging level for a script by setting the <code>min-logging-level</code> script option.</p> <p>A formatted time stamp is also printed in each log message with the exact time that the message was logged, in the local machine's time zone. If you would like to use a different time stamp format, edit the <code>log-timestamp-format</code> value in the <code>config.yml</code>.</p>"},{"location":"scripts/writingscripts/#non-ascii-characters-in-script-files","title":"Non-ASCII Characters in Script Files","text":"<p>Jython reads and compiles script files using ASCII encoding. This means that it won't recognize non-ASCII characters in the file. You may see a <code>SyntaxError</code> when you load a script with non-ASCII characters. Additionally, in Python 2, the <code>str</code> type is a collection of 8-bit characters. Consequently, all characters in the English alphabet (and some basic symbols) can be represented using these 8-bit characters, but special symbols and characters from non-Latin alphabets cannot. There are a couple ways to work around these two constraints:</p>"},{"location":"scripts/writingscripts/#workaround-1","title":"Workaround 1","text":"<p>Jython allows you to specify the encoding of your script file. This is done by specifying an encoding declaration in your script. This ensures that when Jython reads and compiles the file, it will recognize the non-ASCII characters. Add the following to the first or second line of your script file:</p> <p><code>#coding: utf-8</code></p> <p>Of course, you can replace <code>utf-8</code> with whatever character encoding standard you'd like Jython to use. For a list of supported encoding schemes, see this page.</p> Warning <p>You must put the encoding declaration on either the first or second line of your script, as Jython only searches for encoding declarations in this area.</p> <p>Python 2 includes a <code>unicode</code> type, which supports all UTF-8 characters (symbols, non-Latin alphabets, etc.). You can specify that you want to use the <code>unicode</code> type for the string (and not <code>str</code>) by adding a preceding <code>u</code>. For example:</p> <pre><code>#coding: utf-8\n\nfrom org.bukkit import Bukkit\n\nBukkit.broadcastMessage(u'\u041f\u0440\u0438\u0432\u0435\u0442, \u043c\u0438\u0440!') # (1)!\n</code></pre> <ol> <li>Notice that a <code>u</code> directly preceeds the string. This denotes that the string should be treated a special <code>unicode</code> string, not a simple <code>str</code>.</li> </ol>"},{"location":"scripts/writingscripts/#workaround-2","title":"Workaround 2","text":"<p>You can use also use the hex codes of the unicode characters you want to write. You will still need to denote that the string is a unicode string by adding a preceding <code>u</code>, but you don't need to add an encoding declaration at the top of your script file since you aren't actually writing any non-ASCII characters in the file. For example:</p> <pre><code>from org.bukkit import Bukkit\n\nBukkit.broadcastMessage(u'\\u041f\\u0440\\u0438\\u0432\\u0435\\u0442, \\u043c\\u0438\\u0440!')\n</code></pre>"}]}